//==================================================================================================
//  $Id: common.ai,v 1.66.2.1 2003/05/09 09:17:04 abond Exp $
//==================================================================================================
// 显示指定文本
native DebugS               takes string str                            returns nothing
    // 显示指定文本，带1个数字
    native DebugFI              takes string str, integer val               returns nothing
    // 显示指定文本，带1个单位ID
    native DebugUnitID          takes string str, integer val               returns nothing
    // 给指定玩家显示指定文本
    native DisplayText          takes integer p, string str                 returns nothing
    // 给指定玩家显示指定文本，带1个数字
    native DisplayTextI         takes integer p, string str, integer val    returns nothing
    // 给指定玩家显示指定文本，带2个数字
    native DisplayTextII        takes integer p, string str, integer v1, integer v2 returns nothing
    // 给指定玩家显示指定文本，带3个数字
    native DisplayTextIII       takes integer p, string str, integer v1, integer v2, integer v3 returns nothing
    // AI脚本是否允许显示调试文本，供开发者DEBUG
    native DoAiScriptDebug      takes nothing                               returns boolean
    // 获取当前脚本控制的AI玩家（非中立玩家）编号（在1.29及以上版本中，返回的是0~23任意一个实数，以下则是0~11）
    native GetAiPlayer          takes nothing                               returns integer
    // 英雄升级技能相关函数 获取升级的英雄类型
    native GetHeroId            takes nothing                               returns integer
    // 英雄升级技能相关函数 获取英雄等级
    native GetHeroLevelAI       takes nothing                               returns integer
    
    // 获取AI玩家指定类型单位/科技的数量，统计训练/建造/研究指定/研究中及已训练/建造/研究指定/研究完成
    native GetUnitCount         takes integer unitid                        returns integer
    // 获取指定玩家的该类型单位的数量，统计训练/建造/研究指定/研究中及已训练/建造/研究指定/研究完成
    native GetPlayerUnitTypeCount takes player p, integer unitid            returns integer
    // 获取AI玩家指定类型单位的数量，仅统计已训练/建造/研究指定/研究完成
    native GetUnitCountDone     takes integer unitid                        returns integer
    // 指定基地对应类型的单位数，0为第一个基地
    native GetTownUnitCount     takes integer id, integer tn, boolean dn    returns integer
    // 训练/建造/研究指定/研究一个指定类型单位/科技需要消耗的金钱数量
    native GetUnitGoldCost      takes integer unitid                        returns integer
    // 训练/建造/研究指定/研究一个指定类型单位/科技需要消耗的木材数量
    native GetUnitWoodCost      takes integer unitid                        returns integer
    // 获取指定单位/科技类型的建造/训练/研究时间
    native GetUnitBuildTime     takes integer unitid                        returns integer
    
    // 拥有的金矿数，对于亡灵，该函数会检查开始点所有矿，而不是只查闹鬼金矿，如果AI开始点有多个未被其他玩家占据的矿，可能会导致亡灵无法正常采矿，因为HarvestGold（0，n）指向到的是该函数在指定基地返回的第一座矿，如果返回的非闹鬼金矿，侍僧就无法采矿
    native GetMinesOwned        takes nothing                               returns integer
    // 拥有的所有金矿的金钱数量，对于亡灵，该函数会检查开始点所有矿，而不是只查闹鬼金矿，并返回第一座矿，如果此时基地有多个金矿，且金钱数不同，会导致统计值偏差
    native GetGoldOwned         takes nothing                               returns integer
    // 有金矿的基地编号，如果多个基地都有金矿 则返回最小编号，配合TownHasMine检查当前哪座基地有矿时，可以直接获取最小编号，并从该编号查起，避免分基地过多时的逐个查询
    native TownWithMine         takes nothing                               returns integer
    // 指定编号的基地是否有金矿，0为第一个基地
    native TownHasMine          takes integer townid                        returns boolean
    // 指定编号的基地是有城镇单位（主城/基地），0为第一个基地
    native TownHasHall          takes integer townid                        returns boolean
    
    // 指定科技类型当前升级的等级（如攻防默认有3级，大师级科技默认有2级）
    native GetUpgradeLevel      takes integer id                            returns integer
    // 升级指定科技需要消耗的金钱数量，指定id就是指定科技等级
    native GetUpgradeGoldCost   takes integer id                            returns integer
    // 升级指定科技需要消耗的木材数量，指定id就是指定科技等级
    native GetUpgradeWoodCost   takes integer id                            returns integer
    // 获取下一个扩张点
    native GetNextExpansion     takes nothing                               returns integer
    // 获取大型攻击目标，此时暴雪会往攻击组添加默认攻击类型为攻城的单位，似乎该单位是某种建筑或位于建筑群中
    native GetMegaTarget        takes nothing                               returns unit
    // 获取指定玩家正在训练/建造的单位
    native GetBuilding          takes player p                              returns unit
    // 获得敌人进攻组强度
    native GetEnemyPower        takes nothing                               returns integer
    // 设置盟友当前的攻击目标（仅对AI盟友生效）
    native SetAllianceTarget    takes unit id                               returns nothing
    // 获取盟友当前的攻击目标
    native GetAllianceTarget    takes nothing                               returns unit
    // 命令训练/建造/研究指定/研究单位/科技(数量,单位类型,基地)
    native SetProduce           takes integer qty, integer id, integer town returns boolean
    // 取消/反召唤指定单位（亡灵卖建筑），单位正在建造/训练会取消，建造完成时可能会被卖掉
    native Unsummon             takes unit unitid                           returns nothing
    // 建造扩张点/分基地（指定工人类型和建筑类型）
    native SetExpansion         takes unit peon, integer id                 returns boolean
    // 升级指定科技
    native SetUpgrade           takes integer id                            returns boolean
    // 设置英雄升级技能函数
    native SetHeroLevels        takes code func                             returns nothing
    // 是否允许设置新英雄，意义不明，可能和学习技能有关
    native SetNewHeroes         takes boolean state                         returns nothing
    // 购买地精飞艇，运行后AI会自动前往地精实验室并自动购买地精飞艇，无需额外命令
    native PurchaseZeppelin     takes nothing                               returns nothing
    // 训练/建造/研究指定指定数量的合体单位类型（单位类型a,单位类型b,合体成单位类型make），运行后AI会分别训练a和b并合体，直到make数量达标，如角鹰兽和弓箭手合体
    native MergeUnits           takes integer qty, integer a, integer b, integer make returns boolean
    // 训练/建造/研究指定指定数量的变形单位类型，此变形不是英雄/熊德/鸟德/白牛/猎头/坦克的变身/升级，而是十胜石雕像和毁灭者这种额外付费的个体变形，运行后AI会训练变形前单位并变形，直到数量达标
    native ConvertUnits         takes integer qty, integer id               returns boolean
    
    // 启用战役AI
    native SetCampaignAI        takes nothing                               returns nothing
    // 启用对战AI
    native SetMeleeAI           takes nothing                               returns nothing
    // 允许优先攻击英雄
    native SetTargetHeroes      takes boolean state                         returns nothing
    // 允许工人维修建筑
    native SetPeonsRepair       takes boolean state                         returns nothing
    // 启用随机进攻路径
    native SetRandomPaths       takes boolean state                         returns nothing
    // 启用保护真人盟友
    native SetDefendPlayer      takes boolean state                         returns nothing
    // 允许英雄在受伤严重或遭受攻击时尝试逃跑
    native SetHeroesFlee        takes boolean state                         returns nothing
    // 允许英雄购买物品
    native SetHeroesBuyItems    takes boolean state                         returns nothing
    // 没有怜悯（在敌人较弱或弱势时进攻）
    native SetWatchMegaTargets  takes boolean state                         returns nothing
    // 受伤单位（血量50%以下）不编入进攻组
    native SetIgnoreInjured     takes boolean state                         returns nothing
    // 允许英雄拾取物品
    native SetHeroesTakeItems   takes boolean state                         returns nothing
    // 允许单位逃跑
    native SetUnitsFlee         takes boolean state                         returns nothing
    // 允许进攻组逃跑
    native SetGroupsFlee        takes boolean state                         returns nothing
    // 启用慢速采矿（每次采集1金）
    native SetSlowChopping      takes boolean state                         returns nothing
    // 允许变更主基地
    native SetCaptainChanges    takes boolean allow                         returns nothing
    // 启用主动攻击敌人基地
    native SetSmartArtillery    takes boolean state                         returns nothing
    // 防守单位被杀后，AI的补充次数
    native SetReplacementCount  takes integer qty                           returns nothing
    // 允许受伤单位回主基地或生命之泉疗伤
    native GroupTimedLife       takes boolean allow                         returns nothing
    // 允许从进攻组中移除受伤单位（血量50%以下）
    native RemoveInjuries       takes nothing                               returns nothing
    // 从进攻组中移除攻城单位（默认攻击类型为攻城的单位）
    native RemoveSiege          takes nothing                               returns nothing
    // 初始化攻击组
    native InitAssault          takes nothing                               returns nothing
    // 增加指定数量的指定单位类型到攻击组。未被编入的单位类型不会跟随进攻，只会留在开始点
    native AddAssault           takes integer qty, integer id               returns boolean
    // 增加指定数量的指定单位类型到防守组
    native AddDefenders         takes integer qty, integer id               returns boolean
    
    // 获取指定等级范围内的中立敌对玩家控制的单位，即野怪（ture 为可获取飞行单位，false 为不获取），在1.29及以上版本中，中立敌对玩家为玩家24，在以下版本则为12
    native GetCreepCamp         takes integer min, integer max, boolean flyers_ok returns unit
    // 开始获取敌人主基地
    native StartGetEnemyBase    takes nothing                               returns nothing
    // 是否获取到敌人主基地
    native WaitGetEnemyBase     takes nothing                               returns boolean
    // 获取敌人主基地的单位
    native GetEnemyBase         takes nothing                               returns unit
    // 下一个扩张点是否存在具有威胁的单位
    native GetExpansionFoe      takes nothing                               returns unit
    // 获取敌人分基地
    native GetEnemyExpansion    takes nothing                               returns unit
    // 获取扩张点的 X 轴坐标
    native GetExpansionX        takes nothing                               returns integer
    // 获取扩张点的 Y 轴坐标
    native GetExpansionY        takes nothing                               returns integer
    // 设置某种阶段点，意义不明
    native SetStagePoint        takes real x, real y                        returns nothing
    // 让攻击组攻击指定目标
    native AttackMoveKill       takes unit target                           returns nothing
    // 让攻击指组攻击指定坐标
    native AttackMoveXY         takes integer x, integer y                  returns nothing
    // 在指定坐标卸载单位，该命令似乎只对卸载（地精飞艇）技能生效，且AI无需任何辅助代码就能自己控制好飞艇的装卸（运输船则不行），建议勿对飞艇类单位发送忽略防守指令，忽略后AI不会自动控制飞艇卸载
    native LoadZepWave          takes integer x, integer y                  returns nothing
    // 检测自杀攻击是否满足指定条件（指定玩家），自杀指令被暴雪用于战役AI
    native SuicidePlayer        takes player id, boolean check_full         returns boolean
    // 检测自杀攻击组是否满足指定条件（指定玩家），自杀指令被暴雪用于战役AI
    native SuicidePlayerUnits   takes player id, boolean check_full         returns boolean
    // 进攻组是否在战斗
    native CaptainInCombat      takes boolean attack_captain                returns boolean
    // 指定单位是否属于防御塔
    native IsTowered            takes unit target                           returns boolean
    // 清理上一次的AI采集工人分配设置，暴雪在每次运行 HarvestGold 和 HarvestWood 前都进行了清理，但清理后AI可能会交换多个基地之间的农民，比如让A矿的农民去B矿工作，反之亦然
    native ClearHarvestAI       takes nothing                               returns nothing
    // 分配指定数量的工人在指定基地采集金矿，如果金矿和基地之间最短距离的路线可以游过深水地形到达，两栖工人会优先走最短距离到达金矿，但其采集完成返回时自动会停在岸边，就像它忘记自己可以游泳一样
    native HarvestGold          takes integer town, integer peons           returns nothing
    // 分配指定数量的工人在指定基地采集木材，如果树和基地之间最短距离的路线可以游过深水地形到达，两栖工人会优先走最短距离到达树，但其采集完成返回时自动停会在岸边，就像它忘记自己可以游泳一样
    native HarvestWood          takes integer town, integer peons           returns nothing
    // 获取开分基地的工人，系统会随机返回一个工人给AI，但可能返回null，如果AI有盟友，返回null的概率似乎会增加，如果是暗夜，建议另行判断工人是否在金矿内（是否运输单位），因为AI不会命令其离开金矿
    native GetExpansionPeon     takes nothing                               returns unit
    // 停止聚集
    native StopGathering        takes nothing                               returns nothing
    // 在指定坐标增加指定类型的防守单位
    native AddGuardPost         takes integer id, real x, real y            returns nothing
    // 填满防守岗位
    native FillGuardPosts       takes nothing                               returns nothing
    // 返回防守岗位
    native ReturnGuardPosts     takes nothing                               returns nothing
    // 创建攻击组
    native CreateCaptains       takes nothing                               returns nothing
    // 设置指定组（进攻组、防守组、两组一起执行）回家后的聚集坐标，AI默认把单位聚集在主基地的采矿路线上，应该就是这个坐标
    native SetCaptainHome       takes integer which, real x, real y         returns nothing
    // 命令攻击组复位
    native ResetCaptainLocs     takes nothing                               returns nothing
    // 转移基地到指定坐标
    native ShiftTownSpot        takes real x, real y                        returns nothing
    // 让攻击组使用传送到指定坐标
    native TeleportCaptain      takes real x, real y                        returns nothing
    // 清除攻击组当前攻击的目标
    native ClearCaptainTargets  takes nothing                               returns nothing
    // 让攻击组攻击到指定坐标
    native CaptainAttack        takes real x, real y                        returns nothing
    // 让攻击组攻击玩家的单位
    native CaptainVsUnits       takes player id                             returns nothing
    // 让攻击组攻击指定玩家
    native CaptainVsPlayer      takes player id                             returns nothing
    // 让攻击组回家
    native CaptainGoHome        takes nothing                               returns nothing
    // 进攻组是否在家
    native CaptainIsHome        takes nothing                               returns boolean
    // 进攻组是否完整
    native CaptainIsFull        takes nothing                               returns boolean
    // 进攻组是否为空
    native CaptainIsEmpty       takes nothing                               returns boolean
    // 进攻组规模
    native CaptainGroupSize     takes nothing                               returns integer
    // 攻击组准备情况，似乎是百分制，数值越高，准备越充分
    native CaptainReadiness     takes nothing                               returns integer
    // 进攻组是否在撤退
    native CaptainRetreating    takes nothing                               returns boolean
    // 进攻组整体生命值，似乎是百分制且转百分比
    native CaptainReadinessHP   takes nothing                               returns integer
    // 进攻组整体魔法值，似乎是百分制且转百分比
    native CaptainReadinessMa   takes nothing                               returns integer
    // 进攻组是否到达目的地
    native CaptainAtGoal        takes nothing                               returns boolean
    // 地图上是否还有中立敌对玩家的单位，即野怪，在1.29及以上版本中，中立敌对玩家为玩家24，在以下版本则为12
    native CreepsOnMap          takes nothing                               returns boolean
    // 在进攻组添加自杀单位，指定单位类型和数量，自杀指令被暴雪用于战役AI
    native SuicideUnit          takes integer count, integer unitid         returns nothing
    // 在进攻组添加自杀单位，指定单位类型、数量和玩家，自杀指令被暴雪用于战役AI
    native SuicideUnitEx        takes integer ct, integer uid, integer pid  returns nothing
    // 开始进程，AI脚本最多可运行6条进程，最多可有6条进程同时运行（包含默认线程，自行添加之前请检查已调用的默认线程数量），不同进程之间互不干涉（异步），可共用全局变量，但在一条进程运行到读取变量的代码时，可能因变量已在几十秒前被另一个变量改写，造成滞后的假象
    native StartThread          takes code func                             returns nothing
    // 等待指定时间，按秒计时（休眠，不执行任何指令）
    native Sleep                takes real seconds                          returns nothing
    // 单位是否存活
    native UnitAlive            takes unit id                               returns boolean
    // 单位是否可见
    native UnitInvis            takes unit id                               returns boolean
    // 攻击组忽略指定类型单位的数量
    native IgnoredUnits         takes integer unitid                        returns integer
    // AI的任意基地被攻击，与小地图警报的触发条件相同，但只针对基地
    native TownThreatened       takes nothing                               returns boolean
    // 是否允许在未到达目的地前（进攻组/防御组移动过程中）战斗
    native DisablePathing       takes nothing                               returns nothing
    // 获得命令队列中的指令条数
    native SetAmphibious        takes nothing                               returns nothing
    
    // 获取指令类型，可通过BJ发送，未发送时获取的值是0，（暴雪用该指令打破循环，exitwhen CommandsWaiting() != 0，比如电影结束后，BJ发送1给AI，这就实现了游戏初始化时运行AI，但电影结束前AI不进攻，只发展），指令包含类型和数据，需灵活运用，比如设定1类为进攻指令，数据0~1代表不同的攻击点，2类为防守指令，数据0~1代表不同的防御点
    native CommandsWaiting      takes nothing                               returns integer
    // 获取最新的指令类型，可通过BJ发送，未发送时获取的值是0，指令包含类型和数据，需灵活运用，比如设定1类型为进攻指令，数据0~N代表不同的攻击点，2类型为防守指令，数据0~N代表不同的防御点
    native GetLastCommand       takes nothing                               returns integer
    // 获取最新指令的数据，可通过BJ发送，未发送时获取的值是0，指令包含类型和数据，需灵活运用，比如设定1类型为进攻指令，数据0~N代表不同的攻击点，2类型为防守指令，数据0~N代表不同的防御点
    native GetLastData          takes nothing                               returns integer
    // 将最新指令踢出队列
    native PopLastCommand       takes nothing                               returns nothing
    // 获取对战难度
    native MeleeDifficulty      takes nothing                               returns integer
    
    //============================================================================
    //  Globals for all AI scripts
    //============================================================================
    globals
    
        //--------------------------------------------------------------------
        //  HUMANS
        //--------------------------------------------------------------------
    
        // human heroes
        constant integer ARCHMAGE           = 'Hamg'
        constant integer PALADIN            = 'Hpal'
        constant integer MTN_KING           = 'Hmkg'
        constant integer BLOOD_MAGE         = 'Hblm'
    
        // human hero abilities
        constant integer AVATAR             = 'AHav'
        constant integer BASH               = 'AHbh'
        constant integer THUNDER_BOLT       = 'AHtb'
        constant integer THUNDER_CLAP       = 'AHtc'
    
        constant integer DEVOTION_AURA      = 'AHad'
        constant integer DIVINE_SHIELD      = 'AHds'
        constant integer HOLY_BOLT          = 'AHhb'
        constant integer RESURRECTION       = 'AHre'
    
        constant integer BLIZZARD           = 'AHbz'
        constant integer BRILLIANCE_AURA    = 'AHab'
        constant integer MASS_TELEPORT      = 'AHmt'
        constant integer WATER_ELEMENTAL    = 'AHwe'
    
        constant integer BANISH             = 'AHbn'
        constant integer FLAME_STRIKE       = 'AHfs'
        constant integer SUMMON_PHOENIX     = 'AHpx'
        constant integer SIPHON_MANA        = 'AHdr'
    
        // special human heroes
        constant integer JAINA              = 'Hjai'
        constant integer MURADIN            = 'Hmbr'
        constant integer GARITHOS           = 'Hlgr'
        constant integer KAEL               = 'Hkal'
    
        // human units
        constant integer COPTER             = 'hgyr'
        constant integer GYRO               =  COPTER
        constant integer ELEMENTAL          = 'hwat'
        constant integer FOOTMAN            = 'hfoo'
        constant integer FOOTMEN            =  FOOTMAN
        constant integer GRYPHON            = 'hgry'
        constant integer KNIGHT             = 'hkni'
        constant integer MORTAR             = 'hmtm'
        constant integer PEASANT            = 'hpea'
        constant integer PRIEST             = 'hmpr'
        constant integer RIFLEMAN           = 'hrif'
        constant integer RIFLEMEN           =  RIFLEMAN
        constant integer SORCERESS          = 'hsor'
        constant integer TANK               = 'hmtt'
        constant integer STEAM_TANK         =  TANK
        constant integer ROCKET_TANK        = 'hrtt'
        constant integer MILITIA            = 'hmil'
        constant integer SPELL_BREAKER      = 'hspt'
        constant integer HUMAN_DRAGON_HAWK  = 'hdhw'
    
        // special human units
        constant integer BLOOD_PRIEST       = 'hbep'
        constant integer BLOOD_SORCERESS    = 'hbes'
        constant integer BLOOD_PEASANT      = 'nhew'
    
        // human buildings
        constant integer AVIARY             = 'hgra'
        constant integer BARRACKS           = 'hbar'
        constant integer BLACKSMITH         = 'hbla'
        constant integer CANNON_TOWER       = 'hctw'
        constant integer CASTLE             = 'hcas'
        constant integer CHURCH             = 'htws'
        constant integer MAGE_TOWER         =  CHURCH
        constant integer GUARD_TOWER        = 'hgtw'
        constant integer HOUSE              = 'hhou'
        constant integer HUMAN_ALTAR        = 'halt'
        constant integer KEEP               = 'hkee'
        constant integer LUMBER_MILL        = 'hlum'
        constant integer SANCTUM            = 'hars'
        constant integer ARCANE_SANCTUM     =  SANCTUM
        constant integer TOWN_HALL          = 'htow'
        constant integer WATCH_TOWER        = 'hwtw'
        constant integer WORKSHOP           = 'harm'
        constant integer ARCANE_VAULT       = 'hvlt'
        constant integer ARCANE_TOWER       = 'hatw'
    
        // human upgrades
        constant integer UPG_MELEE          = 'Rhme'
        constant integer UPG_RANGED         = 'Rhra'
        constant integer UPG_ARTILLERY      = 'Rhaa'
        constant integer UPG_ARMOR          = 'Rhar'
        constant integer UPG_GOLD           = 'Rhmi'
        constant integer UPG_MASONRY        = 'Rhac'
        constant integer UPG_SIGHT          = 'Rhss'
        constant integer UPG_DEFEND         = 'Rhde'
        constant integer UPG_BREEDING       = 'Rhan'
        constant integer UPG_PRAYING        = 'Rhpt'
        constant integer UPG_SORCERY        = 'Rhst'
        constant integer UPG_LEATHER        = 'Rhla'
        constant integer UPG_GUN_RANGE      = 'Rhri'
        constant integer UPG_WOOD           = 'Rhlh'
        constant integer UPG_SENTINEL       = 'Rhse'
        constant integer UPG_SCATTER        = 'Rhsr'
        constant integer UPG_BOMBS          = 'Rhgb'
        constant integer UPG_HAMMERS        = 'Rhhb'
        constant integer UPG_CONT_MAGIC     = 'Rhss'
        constant integer UPG_FRAGS          = 'Rhfs'
        constant integer UPG_TANK           = 'Rhrt'
        constant integer UPG_FLAK           = 'Rhfc'
        constant integer UPG_CLOUD          = 'Rhcd'
    
        //--------------------------------------------------------------------
        //  ORCS
        //--------------------------------------------------------------------
    
        // orc heroes
        constant integer BLADE_MASTER       = 'Obla'
        constant integer FAR_SEER           = 'Ofar'
        constant integer TAUREN_CHIEF       = 'Otch'
        constant integer SHADOW_HUNTER      = 'Oshd'
    
        // special orc heroes
        constant integer GROM               = 'Ogrh'
        constant integer THRALL             = 'Othr'
    
        // orc hero abilities
        constant integer CRITICAL_STRIKE    = 'AOcr'
        constant integer MIRROR_IMAGE       = 'AOmi'
        constant integer BLADE_STORM        = 'AOww'
        constant integer WIND_WALK          = 'AOwk'
    
        constant integer CHAIN_LIGHTNING    = 'AOcl'
        constant integer EARTHQUAKE         = 'AOeq'
        constant integer FAR_SIGHT          = 'AOfs'
        constant integer SPIRIT_WOLF        = 'AOsf'
    
        constant integer ENDURANE_AURA      = 'AOae'
        constant integer REINCARNATION      = 'AOre'
        constant integer SHOCKWAVE          = 'AOsh'
        constant integer WAR_STOMP          = 'AOws'
    
        constant integer HEALING_WAVE       = 'AOhw'
        constant integer HEX                = 'AOhx'
        constant integer SERPENT_WARD       = 'AOsw'
        constant integer VOODOO             = 'AOvd'
    
        // orc units
        constant integer GUARDIAN           = 'oang'
        constant integer CATAPULT           = 'ocat'
        constant integer WITCH_DOCTOR       = 'odoc'
        constant integer GRUNT              = 'ogru'
        constant integer HEAD_HUNTER        = 'ohun'
        constant integer BERSERKER          = 'otbk'
        constant integer KODO_BEAST         = 'okod'
        constant integer PEON               = 'opeo'
        constant integer RAIDER             = 'orai'
        constant integer SHAMAN             = 'oshm'
        constant integer TAUREN             = 'otau'
        constant integer WYVERN             = 'owyv'
        constant integer BATRIDER           = 'otbr'
        constant integer SPIRIT_WALKER      = 'ospw'
        constant integer SPIRIT_WALKER_M    = 'ospm'
    
        // orc buildings
        constant integer ORC_ALTAR          = 'oalt'
        constant integer ORC_BARRACKS       = 'obar'
        constant integer BESTIARY           = 'obea'
        constant integer FORGE              = 'ofor'
        constant integer FORTRESS           = 'ofrt'
        constant integer GREAT_HALL         = 'ogre'
        constant integer LODGE              = 'osld'
        constant integer STRONGHOLD         = 'ostr'
        constant integer BURROW             = 'otrb'
        constant integer TOTEM              = 'otto'
        constant integer ORC_WATCH_TOWER    = 'owtw'
        constant integer VOODOO_LOUNGE      = 'ovln'
    
        // orc upgrades
        constant integer UPG_ORC_MELEE      = 'Rome'
        constant integer UPG_ORC_RANGED     = 'Rora'
        constant integer UPG_ORC_ARTILLERY  = 'Roaa'
        constant integer UPG_ORC_ARMOR      = 'Roar'
        constant integer UPG_ORC_WAR_DRUMS  = 'Rwdm'
        constant integer UPG_ORC_PILLAGE    = 'Ropg'
        constant integer UPG_ORC_BERSERK    = 'Robs'
        constant integer UPG_ORC_PULVERIZE  = 'Rows'
        constant integer UPG_ORC_ENSNARE    = 'Roen'
        constant integer UPG_ORC_VENOM      = 'Rovs'
        constant integer UPG_ORC_DOCS       = 'Rowd'
        constant integer UPG_ORC_SHAMAN     = 'Rost'
        constant integer UPG_ORC_SPIKES     = 'Rosp'
        constant integer UPG_ORC_BURROWS    = 'Rorb'
        constant integer UPG_ORC_REGEN      = 'Rotr'
        constant integer UPG_ORC_FIRE       = 'Rolf'
        constant integer UPG_ORC_SWALKER    = 'Rowt'
        constant integer UPG_ORC_BERSERKER  = 'Robk'
        constant integer UPG_ORC_NAPTHA     = 'Robf'
        constant integer UPG_ORC_CHAOS      = 'Roch'
    
        // Warcraft 2 orc units
        constant integer OGRE_MAGI          = 'nomg'
        constant integer ORC_DRAGON         = 'nrwm'
        constant integer SAPPER             = 'ngsp'
        constant integer ZEPPLIN            = 'nzep'
        constant integer ZEPPELIN           =  ZEPPLIN
        constant integer W2_WARLOCK         = 'nw2w'
        constant integer PIG_FARM           = 'npgf'
    
        // special orc units
        constant integer CHAOS_GRUNT        = 'nchg'
        constant integer CHAOS_WARLOCK      = 'nchw'
        constant integer CHAOS_RAIDER       = 'nchr'
        constant integer CHAOS_PEON         = 'ncpn'
        constant integer CHAOS_KODO         = 'nckb'
        constant integer CHAOS_GROM         = 'Opgh'
        constant integer CHAOS_BLADEMASTER  = 'Nbbc'
        constant integer CHAOS_BURROW       = 'ocbw'
    
        //--------------------------------------------------------------------
        //  UNDEAD
        //--------------------------------------------------------------------
    
        // undead heroes
        constant integer DEATH_KNIGHT       = 'Udea'
        constant integer DREAD_LORD         = 'Udre'
        constant integer LICH               = 'Ulic'
        constant integer CRYPT_LORD         = 'Ucrl'
    
        // special undead heroes
        constant integer MALGANIS           = 'Umal'
        constant integer TICHONDRIUS        = 'Utic'
        constant integer PIT_LORD           = 'Npld'
        constant integer DETHEROC           = 'Udth'
    
        // undead hero abilities
        constant integer SLEEP              = 'AUsl'
        constant integer VAMP_AURA          = 'AUav'
        constant integer CARRION_SWARM      = 'AUcs'
        constant integer INFERNO            = 'AUin'
    
        constant integer DARK_RITUAL        = 'AUdr'
        constant integer DEATH_DECAY        = 'AUdd'
        constant integer FROST_ARMOR        = 'AUfu'
        constant integer FROST_NOVA         = 'AUfn'
    
        constant integer ANIM_DEAD          = 'AUan'
        constant integer DEATH_COIL         = 'AUdc'
        constant integer DEATH_PACT         = 'AUdp'
        constant integer UNHOLY_AURA        = 'AUau'
    
        constant integer CARRION_SCARAB     = 'AUcb'
        constant integer IMPALE             = 'AUim'
        constant integer LOCUST_SWARM       = 'AUls'
        constant integer THORNY_SHIELD      = 'AUts'
    
        // undead units
        constant integer ABOMINATION        = 'uabo'
        constant integer ACOLYTE            = 'uaco'
        constant integer BANSHEE            = 'uban'
        constant integer PIT_FIEND          = 'ucry'
        constant integer CRYPT_FIEND        =  PIT_FIEND
        constant integer FROST_WYRM         = 'ufro'
        constant integer GARGOYLE           = 'ugar'
        constant integer GARGOYLE_MORPH     = 'ugrm'
        constant integer GHOUL              = 'ugho'
        constant integer MEAT_WAGON         = 'umtw'
        constant integer NECRO              = 'unec'
        constant integer SKEL_WARRIOR       = 'uske'
        constant integer SHADE              = 'ushd'
        constant integer UNDEAD_BARGE       = 'uarb'
        constant integer OBSIDIAN_STATUE    = 'uobs'
        constant integer OBS_STATUE         =  OBSIDIAN_STATUE
        constant integer BLK_SPHINX         = 'ubsp'
    
        // undead buildings
        constant integer UNDEAD_MINE        = 'ugol'
        constant integer UNDEAD_ALTAR       = 'uaod'
        constant integer BONEYARD           = 'ubon'
        constant integer GARG_SPIRE         = 'ugsp'
        constant integer NECROPOLIS_1       = 'unpl'    // normal
        constant integer NECROPOLIS_2       = 'unp1'    // upgraded once
        constant integer NECROPOLIS_3       = 'unp2'    // full upgrade
        constant integer SAC_PIT            = 'usap'
        constant integer CRYPT              = 'usep'
        constant integer SLAUGHTERHOUSE     = 'uslh'
        constant integer DAMNED_TEMPLE      = 'utod'
        constant integer ZIGGURAT_1         = 'uzig'    // normal
        constant integer ZIGGURAT_2         = 'uzg1'    // upgraded
        constant integer ZIGGURAT_FROST     = 'uzg2'    // frost tower
        constant integer GRAVEYARD          = 'ugrv'
        constant integer TOMB_OF_RELICS     = 'utom'
    
        // undead upgrades
        constant integer UPG_UNHOLY_STR     = 'Rume'
        constant integer UPG_CR_ATTACK      = 'Rura'
        constant integer UPG_UNHOLY_ARMOR   = 'Ruar'
        constant integer UPG_CANNIBALIZE    = 'Ruac'
        constant integer UPG_GHOUL_FRENZY   = 'Rugf'
        constant integer UPG_FIEND_WEB      = 'Ruwb'
        constant integer UPG_ABOM           = 'Ruab'
        constant integer UPG_STONE_FORM     = 'Rusf'
        constant integer UPG_NECROS         = 'Rune'
        constant integer UPG_BANSHEE        = 'Ruba'
        constant integer UPG_MEAT_WAGON     = 'Rump'
        constant integer UPG_WYRM_BREATH    = 'Rufb'
        constant integer UPG_SKEL_LIFE      = 'Rusl'
        constant integer UPG_SKEL_MASTERY   = 'Rusm'
        constant integer UPG_EXHUME         = 'Ruex'
        constant integer UPG_SACRIFICE      = 'Rurs'
        constant integer UPG_ABOM_EXPL      = 'Ruax'
        constant integer UPG_CR_ARMOR       = 'Rucr'
        constant integer UPG_PLAGUE         = 'Rupc'
        constant integer UPG_BLK_SPHINX     = 'Rusp'
        constant integer UPG_BURROWING      = 'Rubu'
    
        //--------------------------------------------------------------------
        //  ELVES
        //--------------------------------------------------------------------
    
        // elf heroes
        constant integer DEMON_HUNTER       = 'Edem'
        constant integer DEMON_HUNTER_M     = 'Edmm'
        constant integer KEEPER             = 'Ekee'
        constant integer MOON_CHICK         = 'Emoo'
        constant integer MOON_BABE          =  MOON_CHICK
        constant integer MOON_HONEY         =  MOON_CHICK
        constant integer WARDEN             = 'Ewar'
    
        // special elf heroes
        constant integer SYLVANUS           = 'Hvwd'
        constant integer CENARIUS           = 'Ecen'
        constant integer ILLIDAN            = 'Eevi'
        constant integer ILLIDAN_DEMON      = 'Eevm'
        constant integer MAIEV              = 'Ewrd'
    
        // elf hero abilities
        constant integer FORCE_NATURE       = 'AEfn'
        constant integer ENT_ROOTS          = 'AEer'
        constant integer THORNS_AURA        = 'AEah'
        constant integer TRANQUILITY        = 'AEtq'
    
        constant integer EVASION            = 'AEev'
        constant integer IMMOLATION         = 'AEim'
        constant integer MANA_BURN          = 'AEmb'
        constant integer METAMORPHOSIS      = 'AEme'
    
        constant integer SEARING_ARROWS     = 'AHfa'
        constant integer SCOUT              = 'AEst'
        constant integer STARFALL           = 'AEsf'
        constant integer TRUESHOT           = 'AEar'
    
        constant integer BLINK              = 'AEbl'
        constant integer FAN_KNIVES         = 'AEfk'
        constant integer SHADOW_TOUCH       = 'AEsh'
        constant integer VENGEANCE          = 'AEsv'
    
        // elf units
        constant integer WISP               = 'ewsp'
        constant integer ARCHER             = 'earc'
        constant integer DRUID_TALON        = 'edot'
        constant integer DRUID_TALON_M      = 'edtm'
        constant integer BALLISTA           = 'ebal'
        constant integer DRUID_CLAW         = 'edoc'
        constant integer DRUID_CLAW_M       = 'edcm'
        constant integer DRYAD              = 'edry'
        constant integer HIPPO              = 'ehip'
        constant integer HIPPO_RIDER        = 'ehpr'
        constant integer HUNTRESS           = 'esen'
        constant integer CHIMAERA           = 'echm'
        constant integer ENT                = 'efon'
        constant integer MOUNTAIN_GIANT     = 'emtg'
        constant integer FAERIE_DRAGON      = 'efdr'
    
        // special elf units
        constant integer HIGH_ARCHER        = 'nhea'
        constant integer HIGH_FOOTMAN       = 'hcth'
        constant integer HIGH_FOOTMEN       =  HIGH_FOOTMAN
        constant integer HIGH_SWORDMAN      = 'hhes'
        constant integer DRAGON_HAWK        = 'nws1'
        constant integer CORRUPT_TREANT     = 'nenc'
        constant integer POISON_TREANT      = 'nenp'
        constant integer PLAGUE_TREANT      = 'nepl'
        constant integer SHANDRIS           = 'eshd'
    
        // elf buildings
        constant integer ANCIENT_LORE       = 'eaoe'
        constant integer ANCIENT_WAR        = 'eaom'
        constant integer ANCIENT_WIND       = 'eaow'
        constant integer TREE_AGES          = 'etoa'
        constant integer TREE_ETERNITY      = 'etoe'
        constant integer TREE_LIFE          = 'etol'
        constant integer ANCIENT_PROTECT    = 'etrp'
        constant integer ELF_ALTAR          = 'eate'
        constant integer BEAR_DEN           = 'edol'
        constant integer CHIMAERA_ROOST     = 'edos'
        constant integer HUNTERS_HALL       = 'edob'
        constant integer MOON_WELL          = 'emow'
        constant integer ELF_MINE           = 'egol'
        constant integer DEN_OF_WONDERS     = 'eden'
    
        // special elf buildings
        constant integer ELF_FARM           = 'nefm'
        constant integer ELF_GUARD_TOWER    = 'negt'
        constant integer HIGH_SKY           = 'negm'
        constant integer HIGH_EARTH         = 'negf'
        constant integer HIGH_TOWER         = 'negt'
        constant integer ELF_HIGH_BARRACKS  = 'nheb'
        constant integer CORRUPT_LIFE       = 'nctl'
        constant integer CORRUPT_WELL       = 'ncmw'
        constant integer CORRUPT_PROTECTOR  = 'ncap'
        constant integer CORRUPT_WAR        = 'ncaw'
    
        // elf upgrades
        constant integer UPG_STR_MOON       = 'Resm'
        constant integer UPG_STR_WILD       = 'Resw'
        constant integer UPG_MOON_ARMOR     = 'Rema'
        constant integer UPG_HIDES          = 'Rerh'
        constant integer UPG_ULTRAVISION    = 'Reuv'
        constant integer UPG_BLESSING       = 'Renb'
        constant integer UPG_SCOUT          = 'Resc'
        constant integer UPG_GLAIVE         = 'Remg'
        constant integer UPG_BOWS           = 'Reib'
        constant integer UPG_MARKSMAN       = 'Remk'
        constant integer UPG_DRUID_TALON    = 'Redt'
        constant integer UPG_DRUID_CLAW     = 'Redc'
        constant integer UPG_ABOLISH        = 'Resi'
        constant integer UPG_CHIM_ACID      = 'Recb'
        constant integer UPG_HIPPO_TAME     = 'Reht'
        constant integer UPG_BOLT           = 'Repd'
        constant integer UPG_MARK_CLAW      = 'Reeb'
        constant integer UPG_MARK_TALON     = 'Reec'
        constant integer UPG_HARD_SKIN      = 'Rehs'
        constant integer UPG_RESIST_SKIN    = 'Rers'
        constant integer UPG_WELL_SPRING    = 'Rews'
    
        //--------------------------------------------------------------------
        // Neutral
        //--------------------------------------------------------------------
        constant integer DEMON_GATE         = 'ndmg'
        constant integer FELLHOUND          = 'nfel'
        constant integer INFERNAL           = 'ninf'
        constant integer DOOMGUARD          = 'nbal'
        constant integer SATYR              = 'nsty'
        constant integer TRICKSTER          = 'nsat'
        constant integer SHADOWDANCER       = 'nsts'
        constant integer SOULSTEALER        = 'nstl'
        constant integer HELLCALLER         = 'nsth'
        constant integer SKEL_ARCHER        = 'nska'
        constant integer SKEL_MARKSMAN      = 'nskm'
        constant integer SKEL_BURNING       = 'nskf'
        constant integer SKEL_GIANT         = 'nskg'
        constant integer FURBOLG            = 'nfrl'
        constant integer FURBOLG_TRACKER    = 'nfrb'
        constant integer FURBOLG_SHAMAN     = 'nfrs'
        constant integer FURBOLG_CHAMP      = 'nfrg'
        constant integer FURBOLG_ELDER      = 'nfre'
    
        //--------------------------------------------------------------------
        // NAGA
        //--------------------------------------------------------------------
    
        // naga heroes
        constant integer NAGA_SORCERESS     = 'Nngs' 
        constant integer NAGA_VASHJ         = 'Hvsh' 
    
        // naga units
        constant integer NAGA_DRAGON        = 'nsnp'        // old names
        constant integer NAGA_WITCH         = 'nnsw'
        constant integer NAGA_SERPENT       = 'nwgs' 
        constant integer NAGA_HYDRA         = 'nhyc'    
    
        constant integer NAGA_SLAVE         = 'nmpe'        // peon
        constant integer NAGA_SNAP_DRAGON   =  NAGA_DRAGON  // weak ranged
        constant integer NAGA_COUATL        =  NAGA_SERPENT // weak air
        constant integer NAGA_SIREN         =  NAGA_WITCH   // caster
        constant integer NAGA_MYRMIDON      = 'nmyr'        // knight
        constant integer NAGA_REAVER        = 'nnmg'        // footman
        constant integer NAGA_TURTLE        =  NAGA_HYDRA   // siege
        constant integer NAGA_ROYAL         = 'nnrg'        // royal guard
    
        // naga buildings
        constant integer NAGA_TEMPLE        = 'nntt'        // town hall
        constant integer NAGA_CORAL         = 'nnfm'        // farm
        constant integer NAGA_SHRINE        = 'nnsa'        // sirens & couatls
        constant integer NAGA_SPAWNING      = 'nnsg'        // myrm, snap dragon, hydra
        constant integer NAGA_GUARDIAN      = 'nntg'        // tower
        constant integer NAGA_ALTAR         = 'nnad'        // altar
    
        // naga upgrades
        constant integer UPG_NAGA_ARMOR     = 'Rnam'
        constant integer UPG_NAGA_ATTACK    = 'Rnat'
        constant integer UPG_NAGA_ABOLISH   = 'Rnsi'
        constant integer UPG_SIREN          = 'Rnsw'
        constant integer UPG_NAGA_ENSNARE   = 'Rnen'
    
    
        //--------------------------------------------------------------------
        constant integer M1                 =    60
        constant integer M2                 =  2*60
        constant integer M3                 =  3*60
        constant integer M4                 =  4*60
        constant integer M5                 =  5*60
        constant integer M6                 =  6*60
        constant integer M7                 =  7*60
        constant integer M8                 =  8*60
        constant integer M9                 =  9*60
        constant integer M10                = 10*60
        constant integer M11                = 11*60
        constant integer M12                = 12*60
        constant integer M13                = 13*60
        constant integer M14                = 14*60
        constant integer M15                = 15*60
    
        constant integer EASY               = 1
        constant integer NORMAL             = 2
        constant integer HARD               = 3
        constant integer INSANE             = 4 // not used
    
        constant integer MELEE_NEWBIE       = 1
        constant integer MELEE_NORMAL       = 2
        constant integer MELEE_INSANE       = 3
    
        constant integer ATTACK_CAPTAIN     = 1
        constant integer DEFENSE_CAPTAIN    = 2
        constant integer BOTH_CAPTAINS      = 3
    
        constant integer BUILD_UNIT         = 1
        constant integer BUILD_UPGRADE      = 2
        constant integer BUILD_EXPAND       = 3
    
        constant integer UPKEEP_TIER1       = 50
        constant integer UPKEEP_TIER2       = 80
    
        //--------------------------------------------------------------------
    
        player  ai_player
    
        integer sleep_seconds
        integer total_gold              = 0
        integer total_wood              = 0
        integer gold_buffer             = 0 // usually for potion money
        integer difficulty              = NORMAL
        integer exp_seen                = 0
        integer racial_farm             = 'hhou'
        integer hero_id                 = 'Hamg'
        integer hero_id2                = 'Hmkg'
        integer hero_id3                = 'Hpal'
        integer array skill
        integer array skills1
        integer array skills2
        integer array skills3
        integer max_hero_level          = 0
    
        integer array harass_qty
        integer array harass_max
        integer array harass_units
        integer harass_length           = 0
    
        integer array defense_qty
        integer array defense_units
        integer defense_length          = 0
    
        integer array build_qty
        integer array build_type
        integer array build_item
        integer array build_town
        integer build_length            = 0
    
        integer campaign_gold_peons     = 5
        integer campaign_wood_peons     = 3
        integer campaign_basics_speed   = 5
    
        integer min_creeps              = -1
        integer max_creeps              = -1
    
        boolean harvest_town1           = true
        boolean harvest_town2           = true
        boolean harvest_town3           = true
        boolean do_campaign_farms       = true
        boolean two_heroes              = false
        boolean allow_air_creeps        = false
        boolean take_exp                = false
        boolean allow_signal_abort      = false
        boolean ready_for_zeppelin      = true
        boolean get_zeppelin            = false
    
        boolean build_campaign_attackers = true
    
        boolean do_debug_cheats         = false
        boolean trace_on                = true
        boolean zep_next_wave           = false
        boolean form_group_timeouts     = true
    endglobals
    
    //============================================================================
    // 根据玩家插槽查询玩家，插槽从1开始计算，玩家从0开始计算，玩家数字恒比插槽少1
    function PlayerEx takes integer slot returns player
        return Player(slot-1)
    endfunction
    
    //============================================================================
    // 显示文本，带1个指定文本
    function Trace takes string message returns nothing
        if trace_on then
            call DisplayText(GetAiPlayer(),message)
        endif
    endfunction
    
    //============================================================================
    // 显示文本，带1个指定文本，1个整数
    function TraceI takes string message, integer val returns nothing
        if trace_on then
            call DisplayTextI(GetAiPlayer(),message,val)
        endif
    endfunction
    
    //============================================================================
    // 显示文本，带1个指定文本，2个整数
    function TraceII takes string message, integer v1, integer v2 returns nothing
        if trace_on then
            call DisplayTextII(GetAiPlayer(),message,v1,v2)
        endif
    endfunction
    
    //============================================================================
    // 显示文本，带1个指定文本，3个整数
    function TraceIII takes string message, integer v1, integer v2, integer v3 returns nothing
        if trace_on then
            call DisplayTextIII(GetAiPlayer(),message,v1,v2,v3)
        endif
    endfunction
    
    //============================================================================
    // 初始化AI玩家
    function InitAI takes nothing returns nothing
        set ai_player = Player(GetAiPlayer())
        set sleep_seconds = 0
        call StopGathering()
    endfunction
    
    //============================================================================
    // 标准AI初始化程序，运行后AI将开始工作，可指定3条线程并使其开始运行
    function StandardAI takes code heroes, code peons, code attacks returns nothing
    
        local boolean isNewbie = (MeleeDifficulty() == MELEE_NEWBIE)
    
        call InitAI()
    
        call SetMeleeAI()
    
        call SetDefendPlayer(true)
        call SetGroupsFlee(not isNewbie)
        call SetHeroesBuyItems(not isNewbie)
        call SetHeroesFlee(true)
        call SetHeroesTakeItems(true)
        call SetIgnoreInjured(true)
        call SetPeonsRepair(true)
        call SetSmartArtillery(not isNewbie)
        call SetTargetHeroes(not isNewbie)
        call SetUnitsFlee(not isNewbie)
        call SetWatchMegaTargets(true)
    
        call CreateCaptains()
    
        call SetHeroLevels(heroes)
    
        call Sleep(0.1)
        call StartThread(peons)
        call StartThread(attacks)
    endfunction
    
    //============================================================================
    //  Utility Functions
    //============================================================================
    // 获取最小值
    function Min takes integer A, integer B returns integer
        if A < B then
            return A
        else
            return B
        endif
    endfunction
    // 获取最大值
    function Max takes integer A, integer B returns integer
        if A > B then
            return A
        else
            return B
        endif
    endfunction
    // 设置运输下一波状态开启，用于飞艇空投，但鉴于AI本身会使用飞艇，无需使用该程序
    function SetZepNextWave takes nothing returns nothing
        set zep_next_wave = true
    endfunction
    // 自杀休眠倒计时，当指定的时间小于等于0时 及 触发器有命令传入时会退出休眠
    function SuicideSleep takes integer seconds returns nothing
        set sleep_seconds = sleep_seconds - seconds
        loop
            exitwhen seconds <= 0
            exitwhen allow_signal_abort and CommandsWaiting() != 0
    
            if seconds >= 5 then
                call Sleep(5)
                set seconds = seconds - 5
            else
                call Sleep(seconds)
                set seconds = 0
            endif
        endloop
    endfunction
    
    //============================================================================
    // 等待信号，等待从触发器发送的命令，若未发送命令，不会执行下一步
    function WaitForSignal takes nothing returns integer
        local integer cmd
        local boolean display = false //xxx
        loop
            exitwhen CommandsWaiting() != 0
    
            //xxx
            call Trace("waiting for a signal to begin AI script...\n")
            set display = true
            call Sleep(2)
            exitwhen CommandsWaiting() != 0
            call Sleep(2)
            exitwhen CommandsWaiting() != 0
            call Sleep(2)
            exitwhen CommandsWaiting() != 0
            call Sleep(2)
            exitwhen CommandsWaiting() != 0
            call Sleep(2)
            //xxx
    
        endloop
    
        //xxx
        if display then
            call Trace("signal received, beginning AI script\n")
        endif
        //xxx
    
        set cmd = GetLastCommand()
        call PopLastCommand()
        return cmd
    endfunction

    //============================================================================
    // 设置战役采木工人数量（指定数量）
    function SetWoodPeons takes integer count returns nothing
        set campaign_wood_peons = count
    endfunction
    
    //============================================================================
    // 设置战役采金工人数量（指定数量）
    function SetGoldPeons takes integer count returns nothing
        set campaign_gold_peons = count
    endfunction
    
    //============================================================================
    // 设置战役默认采木工人数量（传真时设置3个工人采木，传假时设置0个）
    function SetHarvestLumber takes boolean harvest returns nothing
        if harvest then
            set campaign_wood_peons = 3
        else
            set campaign_wood_peons = 0
        endif
    endfunction
    
    //============================================================================
    // 启用/禁用 组超时设置
    function SetFormGroupTimeouts takes boolean state returns nothing
        set form_group_timeouts = state
    endfunction
    
    //============================================================================
    // 设置是否建造人口建筑
    function DoCampaignFarms takes boolean state returns nothing
        set do_campaign_farms = state
    endfunction
    
    //============================================================================
    // 获取小型中立敌对玩家的单位（0~9级之间，不含飞行单位）
    function GetMinorCreep takes nothing returns unit
        return GetCreepCamp(0,9,false)
    endfunction
    
    //============================================================================
     // 获取大型中立敌对玩家的单位（10~100级之间，不含飞行单位）
    function GetMajorCreep takes nothing returns unit
        return GetCreepCamp(10,100,allow_air_creeps)
    endfunction
    
    //============================================================================
    // 获取当前AI玩家的黄金数（指定玩家）
    function GetGold takes nothing returns integer
        return GetPlayerState(ai_player,PLAYER_STATE_RESOURCE_GOLD)
    endfunction
    
    //============================================================================
    // 获取当前AI玩家的木材数
    function GetWood takes nothing returns integer
        return GetPlayerState(ai_player,PLAYER_STATE_RESOURCE_LUMBER)
    endfunction
    
    //============================================================================
    // 初始化建造序列数组
    function InitBuildArray takes nothing returns nothing
        set build_length = 0
    endfunction
    
    //============================================================================
    // 初始化攻击组数组
    function InitAssaultGroup takes nothing returns nothing
        set harass_length = 0
    endfunction
    
    //============================================================================
    // 初始化防御组数组
    function InitDefenseGroup takes nothing returns nothing
        set defense_length = 0
    endfunction
    
    //============================================================================
    // 初始化攻击组（包含初始化攻击组数组长度、移除受伤单位、移除攻城单位3条命令）
    function InitMeleeGroup takes nothing returns nothing
        call InitAssaultGroup()
        call RemoveInjuries()
        call RemoveSiege()
    endfunction
    
    //============================================================================
    // 准备自杀（包含初始化攻击组数组、初始化防御组数组、采集（金和木）工人指令4条命令）
    function PrepFullSuicide takes nothing returns nothing
        call InitAssaultGroup()
        call InitDefenseGroup()
        set campaign_gold_peons = 0
        set campaign_wood_peons = 0
    endfunction
    
    //============================================================================
    // 设置3种难度AI的防守单位补充次数
    function SetReplacements takes integer easy, integer med, integer hard returns nothing
        if difficulty == EASY then
            call SetReplacementCount(easy)
        elseif difficulty == NORMAL then
            call SetReplacementCount(med)
        else
            call SetReplacementCount(hard)
        endif
    endfunction
    
    //============================================================================
    // 开启指定线程
    function StartTownBuilder takes code func returns nothing
        call StartThread(func)
    endfunction
    
    //============================================================================
    // 设置建造序列，每个建造/训练命令都会被统一引导到此写入建造先后的排序，等待系统循环检索建造/训练，当 build_length 重置时，系统循环重置
    function SetBuildAll takes integer t, integer qty, integer unitid, integer town returns nothing
        if qty > 0 then
            set build_qty[build_length] = qty
            set build_type[build_length] = t
            set build_item[build_length] = unitid
            set build_town[build_length] = town
            set build_length = build_length + 1
        endif
    endfunction
    
    //============================================================================
    // 训练/建造/研究指定指定数量的指定类型单位/科技
    function SetBuildUnit takes integer qty, integer unitid returns nothing
        call SetBuildAll(BUILD_UNIT,qty,unitid,-1)
    endfunction
    
    //============================================================================
    // 继续训练/建造/研究指定指定类型的单位/科技，如果当前训练/建造/研究指定/研究中的该类型单位/科技数量大于等于指定数量，则不建造
    function SetBuildNext takes integer qty, integer unitid returns nothing
        local integer has = GetUnitCount(unitid)
        if has >= qty then
            return
        endif
        call SetBuildAll(BUILD_UNIT,GetUnitCountDone(unitid)+1,unitid,-1)
    endfunction
    
    //============================================================================
    // 训练/建造/研究指定指定类型的单位/科技（指定各AI难度的数量）
    function SetBuildUnitEx takes integer easy, integer med, integer hard, integer unitid returns nothing
        if difficulty == EASY then
            call SetBuildAll(BUILD_UNIT,easy,unitid,-1)
        elseif difficulty == NORMAL then
            call SetBuildAll(BUILD_UNIT,med,unitid,-1)
        else
            call SetBuildAll(BUILD_UNIT,hard,unitid,-1)
        endif
    endfunction
    
    //============================================================================
    // 在指定编号的基地建造指定数量的单位/科技，一般用于在分矿造塔和其他建筑
    function SecondaryTown takes integer town, integer qty, integer unitid returns nothing
        call SetBuildAll(BUILD_UNIT,qty,unitid,town)
    endfunction
    
    //============================================================================
    // 在指定编号的基地建造指定数量的单位/科技，一般用于在分矿造塔和其他建筑
    function SecTown takes integer town, integer qty, integer unitid returns nothing
        call SetBuildAll(BUILD_UNIT,qty,unitid,town)
    endfunction
    
    //============================================================================
    // 研究/升级指定科技（默认简单难度AI不执行该命令，且只研究/升级1级）
    function SetBuildUpgr takes integer qty, integer unitid returns nothing
        if MeleeDifficulty() != MELEE_NEWBIE or qty == 1 then
            call SetBuildAll(BUILD_UPGRADE,qty,unitid,-1)
        endif
    endfunction
    
    //============================================================================
    // 研究/升级指定科技（指定各AI难度的数量，指定研究/升级的级数）
    function SetBuildUpgrEx takes integer easy, integer med, integer hard, integer unitid returns nothing
        if difficulty == EASY then
            call SetBuildAll(BUILD_UPGRADE,easy,unitid,-1)
        elseif difficulty == NORMAL then
            call SetBuildAll(BUILD_UPGRADE,med,unitid,-1)
        else
            call SetBuildAll(BUILD_UPGRADE,hard,unitid,-1)
        endif
    endfunction
    
    //============================================================================
    // 建造分基地
    function SetBuildExpa takes integer qty, integer unitid returns nothing
        call SetBuildAll(BUILD_EXPAND,qty,unitid,-1)
    endfunction
    
    //============================================================================
    // 开始升级科技
    function StartUpgrade takes integer level, integer upgid returns boolean
        local integer gold_cost
        local integer wood_cost
    
        if GetUpgradeLevel(upgid) >= level then
            return true
        endif
    
        set gold_cost = GetUpgradeGoldCost(upgid)
        if total_gold < gold_cost then
            return false
        endif
    
        set wood_cost = GetUpgradeWoodCost(upgid)
        if total_wood < wood_cost then
            return false
        endif
    
        return SetUpgrade(upgid)
    endfunction
    
    //============================================================================
    // 建造/训练指定单位类型，当金大于1000，木大于500时造两个，否则造一个，默认用于检测建造工厂（造兵建筑）
    function BuildFactory takes integer unitid returns nothing
        if GetGold() > 1000 and GetWood() > 500 then
            call SetBuildUnit( 2, unitid )
        else
            call SetBuildUnit( 1, unitid )
        endif
    endfunction
    
    //============================================================================
    // 判断指定单位类型的数量（含建造/训练中）是否等于该单位类型总数量（不含建造/训练中），默认用于检测城镇类型的单位（基地）
    function HallsCompleted takes integer unitid returns boolean
        return GetUnitCount(unitid) == GetUnitCountDone(unitid) 
    endfunction
    
    //============================================================================
    // 在指定分基地建造指定单位类型，一般用于在分矿造塔或其他建筑，训练单位无需使用此命令，AI会使用所有建筑训练，不论其在哪个基地，使用该命令建造/训练的单位会被登记为：制造于该分基地
    function GuardSecondary takes integer townid, integer qty, integer unitid returns nothing
        if TownHasHall(townid) and TownHasMine(townid) then
            call SecondaryTown( townid, qty, unitid )
        endif
    endfunction
    
    //============================================================================
    // 获取指定单位类型的数量（指定是否包含建造/训练中，指定是否区分基地）
    function GetUnitCountEx takes integer unitid, boolean only_done, integer townid returns integer
        if townid == -1 then
            if only_done then
                return GetUnitCountDone(unitid)
            else
                return GetUnitCount(unitid)
            endif
        else
            return GetTownUnitCount(unitid,townid,only_done)
        endif
    endfunction
    
    //============================================================================
    // 数量统计，指定单位类型，指定是否包含建造/训练中（only_done），指定分基地（townid，-1为不限），查询复核条件的单位类型数量
    function TownCountEx takes integer unitid, boolean only_done, integer townid returns integer
    
        local integer have_qty = GetUnitCountEx(unitid,only_done,townid)
    
        if unitid == TOWN_HALL then
            set have_qty = have_qty + GetUnitCountEx(KEEP,false,townid) + GetUnitCountEx(CASTLE,false,townid)
        elseif unitid == KEEP then
            set have_qty = have_qty  + GetUnitCountEx(CASTLE,false,townid)
    
        elseif unitid == WATCH_TOWER then
            set have_qty = have_qty + GetUnitCountEx(GUARD_TOWER,false,townid) + GetUnitCountEx(CANNON_TOWER,false,townid) + GetUnitCountEx(ARCANE_TOWER,false,townid)
    
        elseif unitid == PEASANT then
            set have_qty = have_qty + GetUnitCountEx(MILITIA,false,townid)
    
        elseif unitid == GREAT_HALL then
            set have_qty = have_qty + GetUnitCountEx(STRONGHOLD,false,townid) + GetUnitCountEx(FORTRESS,false,townid)
        elseif unitid == STRONGHOLD then
            set have_qty = have_qty + GetUnitCountEx(FORTRESS,false,townid)
    
        elseif unitid == HEAD_HUNTER then
            set have_qty = have_qty + GetUnitCountEx(BERSERKER,false,townid)
    
        elseif unitid == SPIRIT_WALKER then
            set have_qty = have_qty + GetUnitCountEx(SPIRIT_WALKER_M,false,townid)
        elseif unitid == SPIRIT_WALKER_M then
            set have_qty = have_qty + GetUnitCountEx(SPIRIT_WALKER,only_done,townid)
    
        elseif unitid == NECROPOLIS_1 then
            set have_qty = have_qty + GetUnitCountEx(NECROPOLIS_2,false,townid) + GetUnitCountEx(NECROPOLIS_3,false,townid)
        elseif unitid == NECROPOLIS_2 then
            set have_qty = have_qty + GetUnitCountEx(NECROPOLIS_3,false,townid)
    
        elseif unitid == ZIGGURAT_1 then
            set have_qty = have_qty + GetUnitCountEx(ZIGGURAT_2,false,townid) + GetUnitCountEx(ZIGGURAT_FROST,false,townid)
    
        elseif unitid == GARGOYLE then
            set have_qty = have_qty + GetUnitCountEx(GARGOYLE_MORPH,false,townid)
    
        elseif unitid == TREE_LIFE then
            set have_qty = have_qty + GetUnitCountEx(TREE_AGES,false,townid) + GetUnitCountEx(TREE_ETERNITY,false,townid)
        elseif unitid == TREE_AGES then
            set have_qty = have_qty + GetUnitCountEx(TREE_ETERNITY,false,townid)
    
        elseif unitid == DRUID_TALON then
            set have_qty = have_qty + GetUnitCountEx(DRUID_TALON_M,false,townid)
        elseif unitid == DRUID_TALON_M then
            set have_qty = have_qty + GetUnitCountEx(DRUID_TALON,only_done,townid)
    
        elseif unitid == DRUID_CLAW then
            set have_qty = have_qty + GetUnitCountEx(DRUID_CLAW_M,false,townid)
        elseif unitid == DRUID_CLAW_M then
            set have_qty = have_qty + GetUnitCountEx(DRUID_CLAW,only_done,townid)
    
        elseif unitid == ILLIDAN then
            set have_qty = have_qty + GetUnitCountEx(ILLIDAN_DEMON,false,townid)
    
        endif
        return have_qty
    endfunction
    
    //============================================================================
    // 数量统计，指定单位类型，包含建造/训练中，不限基地，查询复核条件的单位类型数量
    function TownCountDone takes integer base returns integer
        return TownCountEx(base,true,-1)
    endfunction
    
    //============================================================================
    // 数量统计，指定单位类型，不包含建造/训练中，不限基地，查询复核条件的单位类型数量
    function TownCount takes integer base returns integer
        return TownCountEx(base,false,-1)
    endfunction
    
    //============================================================================
    // 基础开分基地，指定单位类型，包含建造/训练中，不限基地，查询复核条件的单位类型数量
    function BasicExpansion takes boolean build_it, integer unitid returns nothing
        if build_it and HallsCompleted(unitid) then
            call SetBuildExpa( TownCount(unitid)+1, unitid )
        endif
    endfunction
    
    //============================================================================
    // 升级科技，研究指定科技类型（baseid）已完成数量的升级科技类型（newid）
    function UpgradeAll takes integer baseid, integer newid returns nothing
        call SetBuildUnit( TownCountDone(baseid), newid )
    endfunction
    
    //============================================================================
    // 数量统计，指定单位类型（base），指定分基地（townid，-1为不限），不否包含建造/训练中，查询复核条件的单位类型数量，默认用于检测城镇类型的单位（基地）
    function TownCountTown takes integer base, integer townid returns integer
        return TownCountEx(base,false,townid)
    endfunction
    
    //============================================================================
    //  FoodPool
    //============================================================================
    // 根据人口占用情况训练指定单位类型，food为当前人口上限，use1为单位类型id1的人口占用（单个），use2为单位类型id2的人口占用（单个），当strong为真时，训练（（food - use1 * TownCount(id1)) / use2）个id2，当strong为假且weak为真时，训练（(food - use2 * TownCount(id2)) / use1）个id1
    function FoodPool takes integer food, boolean weak, integer id1, integer use1, boolean strong, integer id2, integer use2 returns nothing
        if strong then
            call SetBuildUnit( (food - use1 * TownCount(id1)) / use2, id2 )
        elseif weak then
            call SetBuildUnit( (food - use2 * TownCount(id2)) / use1, id1 )
        endif
    endfunction
    
    //============================================================================
    //  MeleeTownHall
    //============================================================================
    // 补造分基地，当指定的基地（townid）有金矿且该基地没有城镇时，补造一个分基地
    function MeleeTownHall takes integer townid, integer unitid returns nothing
        if TownHasMine(townid) and not TownHasHall(townid) then
            call SecondaryTown ( townid, 1, unitid )
        endif
    endfunction
    
    //============================================================================
    // 等待指定的单位类型（不包含建造/训练中）数量达到指定数量，达到之前保持休眠
    function WaitForUnits takes integer unitid, integer qty returns nothing
        loop
            exitwhen TownCountDone(unitid) == qty
            call Sleep(2)
        endloop
    endfunction
    
    //============================================================================
    // 开始训练单位/建造建筑
    function StartUnit takes integer ask_qty, integer unitid, integer town returns boolean
        local integer have_qty
        local integer need_qty
        local integer afford_gold
        local integer afford_wood
        local integer afford_qty
        local integer gold_cost
        local integer wood_cost
    
        //------------------------------------------------------------------------
        // if we have all we're asking for then make nothing
        //
        if town == -1 then
            set have_qty = TownCount(unitid)
        else
            set have_qty = TownCountTown(unitid,town)
        endif
    
        if have_qty >= ask_qty then
            return true
        endif
        set need_qty = ask_qty - have_qty
    
        //------------------------------------------------------------------------
        // limit the qty we're requesting to the amount of resources available
        //
        set gold_cost = GetUnitGoldCost(unitid)
        set wood_cost = GetUnitWoodCost(unitid)
    
        if gold_cost == 0 then
            set afford_gold = need_qty
        else
            set afford_gold = total_gold / gold_cost
        endif
        if afford_gold < need_qty then
            set afford_qty = afford_gold
        else
            set afford_qty = need_qty
        endif
    
        if wood_cost == 0 then
            set afford_wood = need_qty
        else
            set afford_wood = total_wood / wood_cost
        endif
        if afford_wood < afford_qty then
            set afford_qty = afford_wood
        endif
    
        // if we're waiting on gold/wood; pause build orders
        if afford_qty < 1 then
            return false
        endif
    
        //------------------------------------------------------------------------
        // whether we make right now what we're requesting or not, assume we will
        // and deduct the cost of the units from our fake gold total right away
        //
        set total_gold = total_gold - gold_cost * need_qty
        set total_wood = total_wood - wood_cost * need_qty
    
        if total_gold < 0 then
            set total_gold = 0
        endif
        if total_wood < 0 then
            set total_wood = 0
        endif
    
        //------------------------------------------------------------------------
        // give the AI a chance to make the units (it may not be able to right now
        // but that doesn't stop us from trying other units after this as long
        // as we have enough money to make this AND the needed, unbuilt ones)
        //
        return SetProduce(afford_qty,unitid,town)
    endfunction
    
    //============================================================================
    // 等待指定的单位类型（包含建造/训练中）数量大于或等于指定数量，达到之前保持休眠，若休眠120秒后仍未达到，自动退出休眠
    function WaitForTown takes integer towns, integer townid returns nothing
        local integer i = 0
        loop
            call Sleep(10)
            exitwhen TownCount(townid) >= towns
            set i = i + 1
            exitwhen i == 12
        endloop
    endfunction
    
    //============================================================================
    // 开始建造分基地
    function StartExpansion takes integer qty, integer hall returns boolean
        local integer count
        local integer town
        local unit    peon
        local integer gold_cost
    
        set count = TownCount(hall)
        if count >= qty then
            return true
        endif
    
        set town = GetNextExpansion()
        if town == -1 then
            return true
        endif
    
        set take_exp = true
    
        set gold_cost = GetUnitGoldCost(hall)
        if gold_cost > total_gold then
            return false
        endif
        set total_gold = total_gold - gold_cost
    
        if GetExpansionFoe() != null then
            return true
        endif
    
        set peon = GetExpansionPeon()
        if peon != null then
            return SetExpansion(peon,hall)
        endif
    
        return true
    endfunction
    
    //============================================================================
    // 建造核心循环，该程序负责执行所有排队中的建造/训练/研究命令
    function OneBuildLoop takes nothing returns nothing
        local integer index = 0
        local integer qty
        local integer id
        local integer tp
    
        set total_gold = GetGold() - gold_buffer
        set total_wood = GetWood()
    
        loop
            exitwhen index == build_length
    
            set qty = build_qty [index]
            set id  = build_item[index]
            set tp  = build_type[index]
    
            //--------------------------------------------------------------------
            if tp == BUILD_UNIT then
                if not StartUnit(qty,id,build_town[index]) then
                    return
                endif
    
            //--------------------------------------------------------------------
            elseif tp == BUILD_UPGRADE then
                call StartUpgrade(qty,id)
    
            //--------------------------------------------------------------------
            else // tp == BUILD_EXPAND
                if not StartExpansion(qty,id) then
                    return
                endif
            endif
    
            set index = index + 1
        endloop
    endfunction
    
    //============================================================================
    // 错开休眠，休眠 (base + spread * I2R(GetAiPlayer()) / I2R(GetPlayers())) 秒
    function StaggerSleep takes real base, real spread returns nothing
        call Sleep(base + spread * I2R(GetAiPlayer()) / I2R(GetPlayers()))
    endfunction
    
    //============================================================================
    // 建造循环，启用建造核心循环程序，并无限循环
    function BuildLoop takes nothing returns nothing
        call OneBuildLoop()
        call StaggerSleep(1,2)
        loop
            call OneBuildLoop()
            call Sleep(2)
        endloop
    endfunction
    
    //============================================================================
    // 建造线程（建造/训练/升级 分矿、单位和科技）
    function StartBuildLoop takes nothing returns nothing
        call StartThread(function BuildLoop)
    endfunction
    
    //============================================================================
    // 设置初始波次，设置初始波次的时间
    function SetInitialWave takes integer seconds returns nothing
        set sleep_seconds = seconds
    endfunction
    
    //============================================================================
    // 在原基础上增加初始波次的休眠时间
    function AddSleepSeconds takes integer seconds returns nothing
        set sleep_seconds = sleep_seconds + seconds
    endfunction
    
    //============================================================================
    // 永久休眠，使用后不会退出
    function SleepForever takes nothing returns nothing
        call Trace("going to sleep forever\n") //xxx
        loop
            call Sleep(100)
        endloop
    endfunction
    
    //============================================================================
    // 开始游戏，运行后AI会开始建造/训练/升级 单位或科技
    function PlayGame takes nothing returns nothing
        call StartBuildLoop()
        call SleepForever()
    endfunction
    
    //============================================================================
    // 当指定类型的单位/科技少于1个时（包含建造/训练/研究中），建造/训练/研究1个，默认用于补充合体/变形类单位
    function ConvertNeeds takes integer unitid returns nothing
        if GetUnitCount(unitid) < 1 then
            call StartUnit(1,unitid,-1)
        endif
    endfunction
    
    //============================================================================
    // 建造/训练 指定数量（desire）的特殊单位（如角鹰骑士或毁灭者这类合体/变形单位），当指定单位类型的数量（含建造/训练中）大于等于指定数量时，该程序不会运行
    function Conversions takes integer desire, integer unitid returns nothing
    
        if GetUnitCount(unitid) >= desire then
            return
        endif
    
        if unitid == HIPPO_RIDER then
            call ConvertNeeds(ARCHER)
            call ConvertNeeds(HIPPO)
            call MergeUnits(desire,ARCHER,HIPPO,HIPPO_RIDER)
    
        elseif unitid == BLK_SPHINX then
            call ConvertNeeds(OBS_STATUE)
            call ConvertUnits(desire,OBS_STATUE)
        endif
    endfunction
    
    //============================================================================
    // 设置攻击组
    function SetAssaultGroup takes integer qty, integer max, integer unitid returns nothing
        call Conversions(max,unitid)
    
        if qty <= 0 and TownCountDone(unitid) == 0 then
            return
        endif
        set harass_qty[harass_length] = qty
        set harass_max[harass_length] = max
        set harass_units[harass_length] = unitid
        set harass_length = harass_length + 1
    endfunction
    
    //============================================================================
    function Interleave3 takes integer e1, integer m1, integer h1, integer u1, integer e2, integer m2, integer h2, integer u2, integer e3, integer m3, integer h3, integer u3 returns nothing
        local integer i1 = 1
        local integer i2 = 1
        local integer i3 = 1
        local integer q1
        local integer q2
        local integer q3
    
        if difficulty == EASY then
            set q1 = e1
            set q2 = e2
            set q3 = e3
        elseif difficulty == NORMAL then
            set q1 = m1
            set q2 = m2
            set q3 = m3
        else // difficulty == HARD
            set q1 = h1
            set q2 = h2
            set q3 = h3
        endif
    
        loop
            exitwhen q1<=0 and q2<=0 and q3<=0
    
            if q1 > 0 then
                call SetAssaultGroup(i1,i1,u1)
                set q1 = q1 - 1
                set i1 = i1 + 1
            endif
    
            if q2 > 0 then
                call SetAssaultGroup(i2,i2,u2)
                set q2 = q2 - 1
                set i2 = i2 + 1
            endif
    
            if q3 > 0 then
                call SetAssaultGroup(i3,i3,u3)
                set q3 = q3 - 1
                set i3 = i3 + 1
            endif
        endloop
    endfunction
    
    //============================================================================
    // 将指定类型的单位添加到对战攻击组
    function SetMeleeGroup takes integer unitid returns nothing
        if unitid == hero_id then
            call SetAssaultGroup(1,9,unitid)
        else
            call SetAssaultGroup((TownCountDone(unitid)*3)/4,20,unitid)
        endif
    endfunction
    
    //============================================================================
    // 将指定类型的单位添加到防御组，默认用于战役
    function CampaignDefender takes integer level, integer qty, integer unitid returns nothing
        if qty > 0 and difficulty >= level then
            set defense_qty[defense_length] = qty
            set defense_units[defense_length] = unitid
            set defense_length = defense_length + 1
            call Conversions(qty,unitid)
            call SetBuildUnit(qty,unitid)
        endif
    endfunction
    
    //============================================================================
    // 将指定类型的单位添加到防御组（指定各难度AI的添加数量），默认用于战役
    function CampaignDefenderEx takes integer easy, integer med, integer hard, integer unitid returns nothing
        if difficulty == EASY then
            call CampaignDefender(EASY,easy,unitid)
        elseif difficulty == NORMAL then
            call CampaignDefender(NORMAL,med,unitid)
        else
            call CampaignDefender(HARD,hard,unitid)
        endif
    endfunction
    
    //============================================================================
    // 将指定类型的单位添加到战役攻击组（level必须大于等于当前AI难度时才会添加），默认用于战役
    function CampaignAttacker takes integer level, integer qty, integer unitid returns nothing
        if qty > 0 and difficulty >= level then 
            call SetAssaultGroup(qty,qty,unitid)
        endif
    endfunction
    
    //============================================================================
    // 将指定类型的单位添加到攻击组（指定各难度AI的添加数量），默认用于战役
    function CampaignAttackerEx takes integer easy, integer med, integer hard, integer unitid returns nothing
        if difficulty == EASY then
            call CampaignAttacker(EASY,easy,unitid)
        elseif difficulty == NORMAL then
            call CampaignAttacker(NORMAL,med,unitid)
        else
            call CampaignAttacker(HARD,hard,unitid)
        endif
    endfunction
    
    //============================================================================
    // 等待进攻组完成组建，用于等待进攻组补充单位（用testReady指定组的准备情况，为真时需要攻击组准备满50，为假时准备0即可，seconds为最长等待时间）
    function FormGroup takes integer seconds, boolean testReady returns nothing
        local integer index
        local integer count
        local integer unitid
        local integer desire
        local integer readyPercent
    
        // normally test for CaptainReadiness() of 50%
        if testReady == true then
            set readyPercent = 50
            call Trace("forming group, requiring healthy guys\n") //xxx
        else
            set readyPercent = 0
            call Trace("forming group, unit health not important\n") //xxx
        endif
    
        call Trace("trying to gather forces\n") //xxx
    
        loop
            call SuicideSleep(seconds)
            call InitAssault()
    
            set index = 0
            loop
                exitwhen index == harass_length
    
                set unitid = harass_units[index]
                set desire = harass_max[index]
                set count  = TownCountDone(unitid)
    
                call Conversions(desire,unitid)
    
                if count >= desire then
                    call AddAssault(desire,unitid)
                else
                    set desire = harass_qty[index]
    
                    if count < desire then
                        call AddAssault(desire,unitid)
                    else
                        call AddAssault(count,unitid)
                    endif
                endif
    
                set index = index + 1
            endloop
    
            //xxx
            if form_group_timeouts and (sleep_seconds < -60) then
                call Trace("exit form group -- timeout\n")
            elseif CaptainInCombat(true) then
                call Trace("exit form group -- can't form while already in combat\n")
            elseif CaptainIsFull() and CaptainReadiness() >= readyPercent then
                call Trace("exit form group -- ready\n")
            endif
            //xxx
    
            // time out and send group anyway if time has already expired
            exitwhen form_group_timeouts and (sleep_seconds < -60)
            exitwhen CaptainInCombat(true)
            exitwhen CaptainIsFull() and CaptainReadiness() >= readyPercent
        endloop
    endfunction
    
    //============================================================================
    // 获取指定单位/科技类型的建造/训练/研究时间，该时间默认用于备战（等待该时间已补充兵力）
    function WavePrepare takes integer unitid returns integer
        return GetUnitBuildTime(unitid)
    endfunction
    
    //============================================================================
    // 获取等待所需时间
    function PrepTime takes nothing returns integer
        local integer unitid
        local integer missing
        local integer prep
        local integer count
        local integer largest = 30
        local integer index = 0
    
        loop
            exitwhen index == harass_length
    
            set unitid  = harass_units[index]
            set missing = harass_qty[index] + IgnoredUnits(unitid) - TownCount(unitid)
            set prep    = WavePrepare(unitid) * missing
    
            if prep > largest then
                set largest = prep
            endif
    
            set index = index + 1
        endloop
        call TraceI("next wave will require around %d seconds to build and gather\n",largest) //xxx
    
        return largest
    endfunction
    
    //============================================================================
    // 休眠指定时间（seconds），并在休眠后判断攻击组准备是否完成
    function PrepSuicideOnPlayer takes integer seconds returns boolean
        local integer wave_prep   = PrepTime()
        local integer save_length
    
        set save_length = harass_length
        set harass_length = 0
    
        call AddSleepSeconds(seconds)
        if sleep_seconds-wave_prep > 0 then
            call TraceI("going to sleep for %d seconds before gathering next attack wave\n",sleep_seconds-wave_prep) //xxx
            call SuicideSleep(sleep_seconds-wave_prep)
        endif
    
        call Trace("preparing suicide attack wave\n") //xxx
    
        set harass_length = save_length
        if harass_length < 1 then
            call Trace("ERROR - no units specificed, exiting early\n") //xxx
            return false
        endif
    
        return true
    endfunction
    
    //============================================================================
    // 进军休眠，进攻组撤退、进攻组到达目的地、进攻组回到家、进攻组为空 任意事件返回 是 时，退出休眠
    function SleepUntilAtGoal takes nothing returns nothing
        loop
            exitwhen CaptainRetreating()
            exitwhen CaptainAtGoal()        // reached goal
            exitwhen CaptainIsHome()        // failed to path and returned home
            exitwhen CaptainIsEmpty()       // all units died
            call SuicideSleep(3)
        endloop
    endfunction
    
    //============================================================================
    // 战斗休眠，进攻组脱离战斗 或 进攻组为空 时，退出内层休眠，当内层循环退出8次时，退出外层循环，两层循环都退出时，结束休眠
    function SleepInCombat takes nothing returns nothing
        local integer count = 0
        debug call Trace("SleepInCombat\n")
        loop
            loop
                exitwhen not CaptainInCombat(true)  // goal is cleared
                exitwhen CaptainIsEmpty()           // duh
                call SuicideSleep(1)
            endloop
    
            set count = count + 1
            exitwhen count >= 8
        endloop
        debug call Trace("exit SleepInCombat\n")
    endfunction
    
    //============================================================================
    // 命令进攻组移动攻击到指定坐标
    function AttackMoveXYA takes integer x, integer y returns nothing
    
        if zep_next_wave then
            call LoadZepWave(x,y)
            set zep_next_wave = false
        endif
    
        call AttackMoveXY(x,y)
        call SleepUntilAtGoal()
        call SleepInCombat()
    endfunction
    
    //============================================================================
    // 通报各波次进攻情况（默认使用Trace命令发送文字，可能需要打开调试模式）
    function SuicideOnPlayerWave takes nothing returns nothing
        call Trace("waiting for attack wave to enter combat\n") //xxx
        loop
            //xxx
            if allow_signal_abort and CommandsWaiting() != 0 then
                call Trace("ABORT -- attack wave override\n")
            endif
    
            if CaptainInCombat(true) then
                call Trace("done - captain has entered combat\n")
            endif
    
            if CaptainIsEmpty() then
                call Trace("done - all units are dead\n")
            endif
    
            if sleep_seconds < -300 then
                call Trace("done - timeout, took too long to reach engage the enemy\n")
            endif
            //xxx
    
            exitwhen allow_signal_abort and CommandsWaiting() != 0
    
            exitwhen CaptainInCombat(true)
            exitwhen CaptainIsEmpty()
            call SuicideSleep(10)
            exitwhen sleep_seconds < -300
        endloop
    
        call Trace("waiting for attack wave to die\n") //xxx
        loop
            //xxx
            if allow_signal_abort and CommandsWaiting() != 0 then
                call Trace("ABORT - attack wave override\n")
            endif
    
            if CaptainIsEmpty() then
                call Trace("done - all units are dead\n")
            endif
    
            if sleep_seconds < -300 then
                call Trace("done - timeout, took too long to reach engage the enemy\n")
            endif
            //xxx
    
            exitwhen allow_signal_abort and CommandsWaiting() != 0
    
            exitwhen CaptainIsEmpty()
            call SuicideSleep(10)
            exitwhen sleep_seconds < -300
        endloop
    endfunction
    
    //--------------------------------------------------------------------------------------------------
    // 设置各波次进攻，默认用于自杀（战役）
    function CommonSuicideOnPlayer takes boolean standard, boolean bldgs, integer seconds, player p, integer x, integer y returns nothing
        local integer save_peons
    
        if not PrepSuicideOnPlayer(seconds) then
            return
        endif
    
        set save_peons = campaign_wood_peons
        set campaign_wood_peons = 0
    
        loop
            //xxx
            if allow_signal_abort and CommandsWaiting() != 0 then
                call Trace("ABORT -- attack wave override\n")
            endif
            //xxx
    
            exitwhen allow_signal_abort and CommandsWaiting() != 0
    
            loop
                exitwhen allow_signal_abort and CommandsWaiting() != 0
    
                call FormGroup(5,true)
                exitwhen sleep_seconds <= 0
                call TraceI("waiting %d seconds before suicide\n",sleep_seconds) //xxx
            endloop
    
            if standard then
                if bldgs then
                    exitwhen SuicidePlayer(p,sleep_seconds >= -60)
                else
                    exitwhen SuicidePlayerUnits(p,sleep_seconds >= -60)
                endif
            else
                call AttackMoveXYA(x,y)
            endif
    
            call TraceI("waiting %d seconds before timeout\n",60+sleep_seconds) //xxx
            call SuicideSleep(5)
        endloop
    
        set campaign_wood_peons = save_peons
        set harass_length = 0
    
        call SuicideOnPlayerWave()
    endfunction
    
    //--------------------------------------------------------------------------------------------------
    function SuicideOnPlayer takes integer seconds, player p returns nothing
        call CommonSuicideOnPlayer(true,true,seconds,p,0,0)
    endfunction
    
    //--------------------------------------------------------------------------------------------------
    function SuicideOnUnits takes integer seconds, player p returns nothing
        call CommonSuicideOnPlayer(true,false,seconds,p,0,0)
    endfunction
    
    //--------------------------------------------------------------------------------------------------
    function SuicideOnPoint takes integer seconds, player p, integer x, integer y returns nothing
        call CommonSuicideOnPlayer(false,false,seconds,p,x,y)
    endfunction
    
    //============================================================================
    function SuicideUntilSignal takes integer seconds, player p returns nothing
        local integer save
        local integer wave_prep = PrepTime()
    
        loop
            call AddSleepSeconds(seconds)
            if sleep_seconds-wave_prep > 0 then
                call SuicideSleep(sleep_seconds-wave_prep)
            endif
    
            set save = campaign_wood_peons
            set campaign_wood_peons = 0
            loop
                loop
                    call FormGroup(5, true)
                    exitwhen sleep_seconds <= 0
                    exitwhen CommandsWaiting() != 0
                endloop
                exitwhen SuicidePlayer(p,sleep_seconds >= -60)
                exitwhen CommandsWaiting() != 0
                call SuicideSleep(3)
            endloop
            set campaign_wood_peons = save
    
            loop
                exitwhen CaptainIsEmpty()
                exitwhen CommandsWaiting() != 0
                call SuicideSleep(5)
            endloop
            exitwhen CommandsWaiting() != 0
        endloop
    endfunction
    
    //--------------------------------------------------------------------------------------------------
    function SuicideOnce takes integer easy, integer med, integer hard, integer unitid returns nothing
        if difficulty == EASY then
            call SuicideUnit(easy,unitid)
        elseif difficulty == NORMAL then
            call SuicideUnit(med,unitid)
        else
            call SuicideUnit(hard,unitid)
        endif
    endfunction
    
    //--------------------------------------------------------------------------------------------------
    function SuicideUnitA takes integer unitid returns nothing
        if unitid != 0 then
            call SuicideUnit(1,unitid)
        endif
        call Sleep(0.1)
    endfunction
    
    //--------------------------------------------------------------------------------------------------
    function SuicideUnitB takes integer unitid, integer playerid returns nothing
        if unitid != 0 then
            call SuicideUnitEx(1,unitid,playerid)
        endif
        call Sleep(0.1)
    endfunction
    
    //--------------------------------------------------------------------------------------------------
    function SuicideUnits takes integer u1, integer u2, integer u3, integer u4, integer u5, integer u6, integer u7, integer u8, integer u9, integer uA returns nothing
        call Trace("MASS SUICIDE - this script is now technically done\n") //xxx
    
        call PrepFullSuicide()
        loop
            call SuicideUnitA(u1)
            call SuicideUnitA(u2)
            call SuicideUnitA(u3)
            call SuicideUnitA(u4)
            call SuicideUnitA(u5)
            call SuicideUnitA(u6)
            call SuicideUnitA(u7)
            call SuicideUnitA(u8)
            call SuicideUnitA(u9)
            call SuicideUnitA(uA)
        endloop
    endfunction
    
    //--------------------------------------------------------------------------------------------------
    function SuicideUnitsEx takes integer playerid, integer u1, integer u2, integer u3, integer u4, integer u5, integer u6, integer u7, integer u8, integer u9, integer uA returns nothing
        call Trace("MASS SUICIDE - this script is now technically done\n") //xxx
    
        call PrepFullSuicide()
        loop
            call SuicideUnitB(u1,playerid)
            call SuicideUnitB(u2,playerid)
            call SuicideUnitB(u3,playerid)
            call SuicideUnitB(u4,playerid)
            call SuicideUnitB(u5,playerid)
            call SuicideUnitB(u6,playerid)
            call SuicideUnitB(u7,playerid)
            call SuicideUnitB(u8,playerid)
            call SuicideUnitB(u9,playerid)
            call SuicideUnitB(uA,playerid)
        endloop
    endfunction
    
    //--------------------------------------------------------------------------------------------------
    function SuicideOnPlayerEx takes integer easy, integer med, integer hard, player p returns nothing
        if difficulty == EASY then
            call SuicideOnPlayer(easy,p)
        elseif difficulty == NORMAL then
            call SuicideOnPlayer(med,p)
        else
            call SuicideOnPlayer(hard,p)
        endif
    endfunction
    
    //--------------------------------------------------------------------------------------------------
    function SuicideOnUnitsEx takes integer easy, integer med, integer hard, player p returns nothing
        if difficulty == EASY then
            call SuicideOnUnits(easy,p)
        elseif difficulty == NORMAL then
            call SuicideOnUnits(med,p)
        else
            call SuicideOnUnits(hard,p)
        endif
    endfunction
    
    //--------------------------------------------------------------------------------------------------
    function SuicideOnPointEx takes integer easy, integer med, integer hard, player p, integer x, integer y returns nothing
        if difficulty == EASY then
            call SuicideOnPoint(easy,p,x,y)
        elseif difficulty == NORMAL then
            call SuicideOnPoint(med,p,x,y)
        else
            call SuicideOnPoint(hard,p,x,y)
        endif
    endfunction
    
    //============================================================================
    function ForeverSuicideOnPlayer takes integer seconds, player p returns nothing
        local integer length = harass_length
        loop
            exitwhen allow_signal_abort and CommandsWaiting() != 0
            call SuicideOnPlayer(seconds,p)
            set harass_length = length
        endloop
    endfunction
    
    //============================================================================
    // 战斗（循环发送进攻指定目标命令），直至攻击目标死亡或进攻组死光/撤退
    function CommonSleepUntilTargetDead takes unit target, boolean reform returns nothing
        loop
            exitwhen CaptainRetreating()
            exitwhen CaptainReadinessHP() <= 40
    
            exitwhen not UnitAlive(target)
            exitwhen UnitInvis(target) and not IsUnitDetected(target,ai_player)
    
            if not TownThreatened() then
                call AttackMoveKill(target)
            endif
    
            call SuicideSleep(3)
    
            if reform and sleep_seconds < -40 then
                if CaptainInCombat(true) then
                    set sleep_seconds = sleep_seconds + 5
                else
                    set sleep_seconds = 0
                    call FormGroup(1,false)
                endif
            endif
        endloop
    endfunction
    
    //============================================================================
    // 至死方休（指定目标），死为目标死亡或进攻组死光/撤退，会调用战斗程序CommonSleepUntilTargetDead，reform默认为假
    function SleepUntilTargetDead takes unit target returns nothing
        call CommonSleepUntilTargetDead(target,false)
    endfunction
    
    //============================================================================
    function ReformUntilTargetDead takes unit target returns nothing
        debug call Trace("ReformUntilTargetDead\n")
        call CommonSleepUntilTargetDead(target,true)
    endfunction
    
    //============================================================================
    function AttackMoveKillA takes unit target returns nothing
        if target == null then
            call SuicideSleep(3)
            return
        endif
    
        debug call Trace("AttackMoveKillA\n")
        call AttackMoveKill(target)
        call ReformUntilTargetDead(target)
        call SleepInCombat()
    endfunction
    
    //============================================================================
    function MinorCreepAttack takes nothing returns nothing
        local unit target = GetMinorCreep()
        call SetAllianceTarget(target)
        call FormGroup(3, true)
        call AttackMoveKillA(target)
    endfunction
    
    //============================================================================
    function MajorCreepAttack takes nothing returns nothing
        local unit target = GetMajorCreep()
        call SetAllianceTarget(target)
        call FormGroup(3,true)
        call AttackMoveKillA(target)
    endfunction
    
    //============================================================================
    function CreepAttackEx takes nothing returns nothing
        local unit target = GetCreepCamp(min_creeps,max_creeps,allow_air_creeps)
        call SetAllianceTarget(target)
        call FormGroup(3,true)
        call AttackMoveKillA(target)
    endfunction
    
    //============================================================================
    function AnyPlayerAttack takes nothing returns nothing
        local unit hall
    
        set hall = GetEnemyExpansion()
        if hall == null then
            call StartGetEnemyBase()
            loop
                exitwhen not WaitGetEnemyBase()
                call SuicideSleep(1)
            endloop
            set hall = GetEnemyBase()
        endif
    
        call SetAllianceTarget(hall)
        call FormGroup(3,true)
        call AttackMoveKillA(hall)
    endfunction
    
    //============================================================================
    function ExpansionAttack takes nothing returns nothing
        local unit creep = GetExpansionFoe()
        local integer x
    
        call FormGroup(3, true)
        if creep == null then
            set x = GetExpansionX()
            if x != -1 then
                call AttackMoveXYA(x,GetExpansionY())
            endif
        else
            call AttackMoveKillA(creep)
        endif
    endfunction
    
    //============================================================================
    //  AddSiege
    //============================================================================
    function AddSiege takes nothing returns nothing
        call SetAssaultGroup( 0, 9, SHADE       )
        call SetAssaultGroup( 0, 9, MEAT_WAGON  )
        call SetAssaultGroup( 0, 9, MORTAR      )
        call SetAssaultGroup( 0, 9, TANK        )
        call SetAssaultGroup( 0, 9, BALLISTA    )
        call SetAssaultGroup( 0, 9, CATAPULT    )
    endfunction
    
    //===========================================================================
    //  GetAllyCount
    //============================================================================
    function GetAllyCount takes player whichPlayer returns integer
        local integer    playerIndex = 0
        local integer    count = 0
        local player     indexPlayer
    
        loop
            set indexPlayer = Player(playerIndex)
    
            if whichPlayer != indexPlayer then
                if GetPlayerAlliance(whichPlayer,indexPlayer,ALLIANCE_PASSIVE) then
                    if GetPlayerAlliance(indexPlayer,whichPlayer,ALLIANCE_PASSIVE) then
                        if GetPlayerStructureCount(indexPlayer,true) > 0 then
                            set count = count + 1
                        endif
                    endif
                endif
            endif
             
            set playerIndex = playerIndex + 1
            exitwhen playerIndex == 12
        endloop
    
        return count
    endfunction
    
    //============================================================================
    //  SingleMeleeAttack
    //============================================================================
    function SingleMeleeAttack takes boolean needs_exp, boolean has_siege, boolean major_ok, boolean air_units returns nothing
        local boolean   can_siege
        local real      daytime 
        local unit      hall
        local unit      mega
        local unit      creep
        local unit      common
        local integer   minimum
        local boolean   allies
    
        call Trace("===SingleMeleeAttack===\n") //xxx
    
        if TownThreatened() then
            call Trace("sleep 2, town threatened\n") //xxx
            call Sleep(2)
            return
        endif
    
        // purchase zeppelins
        //
        if get_zeppelin and GetGold() > 300 and GetWood() > 100 then
            call Trace("purchase zep\n") //xxx
            call PurchaseZeppelin()
            set get_zeppelin = false
            set ready_for_zeppelin = false
            return
        endif
        set ready_for_zeppelin = true
    
        // coordinate with allies
        //
        set allies = GetAllyCount(ai_player) > 0
        if allies and MeleeDifficulty() != MELEE_NEWBIE then
            set common = GetAllianceTarget()
            if common != null then
                call Trace("join ally force\n") //xxx
                if GetMegaTarget() != null then
                    call AddSiege()
                endif
                call FormGroup(3,true)
                call AttackMoveKillA(common)
                call SetAllianceTarget(null)
                return
            endif
        endif
    
        // take expansions as needed
        //
        if needs_exp then
            call Trace("needs exp\n") //xxx
            set creep = GetExpansionFoe()
            if creep != null then
                call Trace("attack exp\n") //xxx
                call SetAllianceTarget(creep)
                call FormGroup(3,true)
                call AttackMoveKillA(creep)
                call Sleep(20)
                set take_exp = false
                return
            endif
        endif
    
        // all-out attack if the player is weak
        //
        if MeleeDifficulty() != MELEE_NEWBIE then
            set mega = GetMegaTarget()
            if mega != null then
                call Trace("MEGA TARGET!!!\n") //xxx
                call AddSiege()
                call FormGroup(3,true)
                call AttackMoveKillA(mega)
                return
            endif
        endif
    
        // deny player an expansion
        //
        set hall = GetEnemyExpansion()
        set daytime = GetFloatGameState(GAME_STATE_TIME_OF_DAY)
        set can_siege = has_siege and (air_units or (daytime>=4 and daytime<=12))
    
        if hall!=null and (can_siege or not IsTowered(hall)) then
    
            call Trace("test player town attack\n") //xxx
    
            if MeleeDifficulty() == MELEE_NEWBIE then
                set minimum = 3
            elseif allies and MeleeDifficulty() == MELEE_NORMAL then
                set minimum = 1
            else
                set minimum = 0 // HARD, INSANE, and NORMAL with no allies
            endif
    
            if exp_seen >= minimum then
                call Trace("do player town attack\n") //xxx
                set exp_seen = 0
                call AddSiege()
                call SetAllianceTarget(hall)
                call FormGroup(3,true)
                call AttackMoveKillA(hall)
                return
            endif
    
            set exp_seen = exp_seen + 1
        endif
    
        // attack player's main base when siege is available
        //
        if can_siege then
            call Trace("attack player's town\n") //xxx
            call AddSiege()
            call AnyPlayerAttack()
            return
        endif
    
        // extended, more specific method of determining creep levels
        //
        if min_creeps != -1 then
            call TraceI("custom creep attack %d\n",max_creeps) //xxx
            call CreepAttackEx()
            return
        endif
    
        // nothing better to do, so kill a creep camp
        //
        if major_ok then
            call Trace("major creep attack\n") //xxx
            call MajorCreepAttack()
            return
        endif
    
        call Trace("minor creep attack\n") //xxx
        call MinorCreepAttack()
    endfunction
    
    //============================================================================
    // 设置AI是否需要购买飞艇，该设置默认是自动的
    function GetZeppelin takes nothing returns nothing
        if ready_for_zeppelin then
            set get_zeppelin = true
        endif
    endfunction
    PLAYER_STATE_FOOD_CAP_CEILING
    //============================================================================
    // 获取当前AI玩家的已用人口数
    function FoodUsed takes nothing returns integer
        return GetPlayerState(ai_player,PLAYER_STATE_RESOURCE_FOOD_USED)
    endfunction
    
    //============================================================================
    // 获取当前AI玩家的最大人口数（默认为人口建筑提供的数量），默认为100
    function FoodCap takes nothing returns integer
        return GetPlayerState(ai_player,PLAYER_STATE_RESOURCE_FOOD_CAP)
    endfunction
    
    //============================================================================
    // 获取当前AI玩家的可用人口数（人口建筑提供的人口数-已使用的人口数）
    function FoodSpace takes nothing returns integer
        return FoodCap() - FoodUsed()
    endfunction
    
    //============================================================================
    // 获取当前AI玩家人口建筑提供的人口数量，已完成的人口建筑（默认为racial_farm）*该建筑提供的人口数 + 已完成的主城（base指定）*该建筑提供的人口数
    function FoodAvail takes integer base returns integer
        return GetFoodMade(racial_farm) * TownCount(racial_farm) + GetFoodMade(base) * TownCount(base)
    endfunction
    
    //============================================================================
    // 训练进攻组单位
    function BuildAttackers takes nothing returns nothing
        local integer index = 0
        local integer unitid
        local integer desire
        local integer count
    
        loop
            exitwhen index == harass_length
    
            set unitid = harass_units[index]
            set desire = harass_qty[index] + IgnoredUnits(unitid)
            set count  = TownCount(unitid)
    
            if count != desire then
                if not StartUnit(desire,unitid,-1) then
                    return
                endif
            endif
    
            set index = index + 1
        endloop
    endfunction
    
    //============================================================================
    // 训练防御组单位
    function BuildDefenders takes nothing returns nothing
        local integer index = 0
        local integer unitid
        local integer qty
        loop
            exitwhen index == defense_length
    
            set unitid = defense_units[index]
            set qty = defense_qty[index]
    
            call Conversions(qty,unitid)
            call AddDefenders(qty,unitid)
    
            set index = index + 1
        endloop
    endfunction
    
    //============================================================================
    // 战役循环，自动运行战役默认的采集/建造/训练/研究指令
    function CampaignBasicsA takes nothing returns nothing
        local integer food_each = GetFoodMade(racial_farm)
        local integer on_wood
    
        call ClearHarvestAI()
    
        if CaptainInCombat(false) then
            set on_wood = 0
        else
            set on_wood = campaign_wood_peons
        endif
    
        call HarvestGold(0,campaign_gold_peons)
        call HarvestWood(0,on_wood)
    
        if harvest_town1 then
            call HarvestGold(1,campaign_gold_peons)
            call HarvestWood(1,on_wood)
        endif
    
        if harvest_town2 then
            call HarvestGold(2,campaign_gold_peons)
            call HarvestWood(2,on_wood)
        endif
    
        if harvest_town3 then
            call HarvestGold(3,campaign_gold_peons)
            call HarvestWood(3,on_wood)
        endif
    
        if do_campaign_farms and FoodUsed()+food_each-1 > food_each*(TownCount(racial_farm)+1) then
            call StartUnit(TownCount(racial_farm)+1,racial_farm,-1)
        endif
    
        if build_campaign_attackers then
            call BuildAttackers()
        endif
    
        if not CaptainInCombat(false) then
            call BuildDefenders()
        endif
    
        call FillGuardPosts()
        call ReturnGuardPosts()
    endfunction
    
    //============================================================================
    // 战役基础，运行后调用战役循环
    function CampaignBasics takes nothing returns nothing
        call Sleep(1)
        call CampaignBasicsA()
        call StaggerSleep(1,5)
        loop
            call CampaignBasicsA()
            call Sleep(campaign_basics_speed)
        endloop
    endfunction
    
    //============================================================================
    // 设置战役AI
    function CampaignAI takes integer farms, code heroes returns nothing
        if GetGameDifficulty() == MAP_DIFFICULTY_EASY then
            set difficulty = EASY
    
            call SetTargetHeroes(false)
            call SetUnitsFlee(false)
    
        elseif GetGameDifficulty() == MAP_DIFFICULTY_NORMAL then
            set difficulty = NORMAL
    
            call SetTargetHeroes(false)
            call SetUnitsFlee(false)
    
        elseif GetGameDifficulty() == MAP_DIFFICULTY_HARD then
            set difficulty = HARD
    
            call SetPeonsRepair(true)
        else
            set difficulty = INSANE
        endif
    
        call InitAI()
        call InitBuildArray()
        call InitAssaultGroup()
        call CreateCaptains()
    
        call SetNewHeroes(false)
        if heroes != null then
            call SetHeroLevels(heroes)
        endif
    
        call SetHeroesFlee(false)
        call SetGroupsFlee(false)
        call SetSlowChopping(true)
        call GroupTimedLife(false)
        call SetCampaignAI()
        call Sleep(0.1)
    
        set racial_farm = farms
        call StartThread(function CampaignBasics)
        call StartBuildLoop()
    endfunction
    
    //============================================================================
    // 取消建造，运行后取消正在建造/训练/研究的单位/科技
    function UnsummonAll takes nothing returns nothing
        local unit bldg
        loop
            set bldg = GetBuilding(ai_player)
            exitwhen bldg==null
            call Unsummon(bldg)
            call Sleep(2)
        endloop
    endfunction
    
    //============================================================================
    //  SkillArrays
    //============================================================================
    // 获取技能组，让英雄升级后根据 SetSkillArray 的顺序自动学习技能，该代码在1.30~1.31中因官方BUG无法运行，需要手动使用触发或魔改该代码修正
    function SkillArrays takes nothing returns integer
        local integer level = GetHeroLevelAI()
    
        if level > max_hero_level then
            set max_hero_level = level
        endif
    
        if GetHeroId() == hero_id then
            return skills1[level]
        elseif GetHeroId() == hero_id2 then
            return skills2[level]
        else
            return skills3[level]
        endif
    endfunction
    
    //--------------------------------------------------------------------------------------------------
    //  SetSkillArray
    //--------------------------------------------------------------------------------------------------
    // 设置3个英雄的技能学习顺序（index 为1/2/3，分别对应三个英雄），id为三个英雄的单位类型，默认只能设置10级
    function SetSkillArray takes integer index, integer id returns nothing
        local integer i = 1
    
        if index == 1 then
            if hero_id != id then
                return
            endif
            loop
                set skills1[i] = skill[i]
                exitwhen i == 10
                set i = i + 1
            endloop
        elseif index == 2 then
            if hero_id2 != id then
                return
            endif
            loop
                set skills2[i] = skill[i]
                exitwhen i == 10
                set i = i + 1
            endloop
        else
            if hero_id3 != id then
                return
            endif
            loop
                set skills3[i] = skill[i]
                exitwhen i == 10
                set i = i + 1
            endloop
        endif
    endfunction
    
    //============================================================================
    //  AwaitMeleeHeroes
    //============================================================================
    // 等待二发英雄，当首发英雄完成训练/复活，且 【take_exp为真 或 二发英雄存在且完成训练/复活时】 退出休眠，否则一直休眠
    function AwaitMeleeHeroes takes nothing returns nothing
        if GetUnitCountDone(hero_id2) > 0 then
            set two_heroes = true
        endif
        loop
            exitwhen GetUnitCountDone(hero_id)>0 and (take_exp or (not two_heroes or GetUnitCountDone(hero_id2)>0))
            call Sleep(1)
        endloop
    endfunction
    
    //============================================================================
    //  PickMeleeHero 
    //============================================================================
    // 设置对战英雄（含混乱之治和冰封王座），设置4个种族的默认英雄（不含中立）及本局随机顺序（首发，二发，三发），4族之外的种族默认为空，heroes[4]默认为冰封王座新加的英雄，不会出现在混乱之治中
    function PickMeleeHero takes race raceid returns integer
        local integer first
        local integer second
        local integer third
        local integer last
        local integer array heroes
    
        //------------------------------------------------------------------------
        if raceid == RACE_HUMAN then
        //------------------------------------------------------------------------
            set heroes[1] = ARCHMAGE
            set heroes[2] = MTN_KING
            set heroes[3] = PALADIN
            set heroes[4] = BLOOD_MAGE
    
        //------------------------------------------------------------------------
        elseif raceid == RACE_ORC then
        //------------------------------------------------------------------------
            set heroes[1] = BLADE_MASTER
            set heroes[2] = FAR_SEER
            set heroes[3] = TAUREN_CHIEF
            set heroes[4] = SHADOW_HUNTER
    
        //------------------------------------------------------------------------
        elseif raceid == RACE_NIGHTELF then
        //------------------------------------------------------------------------
            set heroes[1] = DEMON_HUNTER
            set heroes[2] = KEEPER
            set heroes[3] = MOON_BABE
            set heroes[4] = WARDEN
    
        //------------------------------------------------------------------------
        elseif raceid == RACE_UNDEAD then
        //------------------------------------------------------------------------
            set heroes[1] = DEATH_KNIGHT
            set heroes[2] = DREAD_LORD
            set heroes[3] = LICH
            set heroes[4] = CRYPT_LORD
        else
            set hero_id = 0
        endif
    
        if VersionCompatible(VERSION_FROZEN_THRONE) then
            set last = 4
        else
            set last = 3
        endif
    
        set first  = GetRandomInt(1,last)
        set second = GetRandomInt(1,last-1)
        set third  = GetRandomInt(1,last-2)
    
        set hero_id        = heroes[first]
        set heroes[first]  = heroes[last]
        set hero_id2       = heroes[second]
        set heroes[second] = heroes[last-1]
        set hero_id3       = heroes[third]
    
        return hero_id
    endfunction
    